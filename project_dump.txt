
# admin/routes.py
# src/admin/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional
from auth.models import User, AdminActionLog
from auth.schemas import UserResponse, AdminActionLogResponse
from content.models import Post
from content.schemas import PostResponse
from subscription.models import Subscription
from subscription.schemas import SubscriptionResponse
from payment.models import Payment, Discount
from payment.schemas import PaymentResponse, DiscountResponse
from auth.routes import get_current_user
from database import get_db

router = APIRouter(prefix="/admin", tags=["admin"])

def check_admin_role(current_user: User = Depends(get_current_user)) -> User:
    """Ensure the user has admin role."""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user


@router.get("/users", response_model=List[UserResponse], dependencies=[Depends(check_admin_role)])
def get_users(
    subscription_level: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve users with optional subscription level filter."""
    query = db.query(User)
    if subscription_level:
        query = query.filter(User.subscription_level == subscription_level)
    return [UserResponse.from_orm(user) for user in query.all()]

@router.patch("/users/{user_id}/subscription", response_model=UserResponse, dependencies=[Depends(check_admin_role)])
def update_user_subscription(
    user_id: int,
    subscription_level: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Update a user's subscription level."""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    user.subscription_level = subscription_level
    db.commit()
    db.refresh(user)
    log = AdminActionLog(admin_id=current_user.id, action=f"Updated subscription level of user {user_id} to {subscription_level}")
    db.add(log)
    db.commit()
    return UserResponse.from_orm(user)

@router.get("/posts", response_model=List[PostResponse], dependencies=[Depends(check_admin_role)])
def get_posts(
    user_id: Optional[int] = None,
    content_type: Optional[str] = None,
    media_type: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve posts with optional filters."""
    query = db.query(Post)
    if user_id:
        query = query.filter(Post.user_id == user_id)
    if content_type:
        query = query.filter(Post.content_type == content_type)
    if media_type:
        query = query.filter(Post.media_type == media_type)
    return [PostResponse.from_orm(post) for post in query.all()]

@router.get("/subscriptions", response_model=List[SubscriptionResponse], dependencies=[Depends(check_admin_role)])
def get_subscriptions(
    level: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve subscriptions with optional level filter."""
    query = db.query(Subscription)
    if level:
        query = query.filter(Subscription.level == level)
    return [SubscriptionResponse.from_orm(sub) for sub in query.all()]

@router.get("/payments", response_model=List[PaymentResponse], dependencies=[Depends(check_admin_role)])
def get_payments(
    status: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve payments with optional status filter."""
    query = db.query(Payment)
    if status:
        query = query.filter(Payment.status == status)
    return [PaymentResponse.from_orm(payment) for payment in query.all()]

@router.get("/logs", response_model=List[AdminActionLogResponse], dependencies=[Depends(check_admin_role)])
def get_admin_logs(db: Session = Depends(get_db), current_user: User = Depends(check_admin_role)):
    """Retrieve admin action logs."""
    return [AdminActionLogResponse.from_orm(log) for log in db.query(AdminActionLog).all()]

# auth/models.py
# src/auth/models.py
from sqlalchemy import Column, Integer, String, Date, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class User(Base):
    """Represents a user in the system."""
    __tablename__ = "users"

    id: int = Column(Integer, primary_key=True, index=True)
    username: str = Column(String, unique=True, index=True, nullable=False)
    email: str = Column(String, unique=True, index=True, nullable=False)
    password_hash: str = Column(String, nullable=False)
    date_of_birth: datetime = Column(Date, nullable=False)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)
    role: str = Column(String, nullable=False, default="user")

    posts = relationship("Post", back_populates="user")
    comments = relationship("Comment", back_populates="user")
    subscriptions = relationship("Subscription", back_populates="user")
    discounts = relationship("Discount", back_populates="user")
    admin_actions = relationship("AdminActionLog", back_populates="admin")
    payments = relationship("Payment", back_populates="user")

class AdminActionLog(Base):
    """Represents a log of admin actions."""
    __tablename__ = "admin_action_logs"

    id: int = Column(Integer, primary_key=True, index=True)
    admin_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    action: str = Column(String, nullable=False)
    timestamp: datetime = Column(DateTime, nullable=False, default=datetime.utcnow)

    admin = relationship("User", back_populates="admin_actions")

class VerificationToken(Base):
    """Tokens for email verification and password reset."""
    __tablename__ = "verification_tokens"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    token: str = Column(String, nullable=False, unique=True)
    token_type: str = Column(String, nullable=False)  # 'verify' or 'reset'
    expiry: datetime = Column(DateTime, nullable=False)

    user = relationship("User")

# auth/routes.py
# src/auth/routes.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import EmailStr
from sqlalchemy.orm import Session
from jose import jwt, JWTError
from datetime import timedelta, datetime, timezone
from auth.services import AuthService
from auth.schemas import UserCreate, UserResponse, UserLogin, Token
from auth.models import User, VerificationToken
from config import settings
from database import get_db
from subscription.models import Subscription

router = APIRouter(prefix="/auth", tags=["auth"])
bearer_scheme = HTTPBearer(auto_error=False)

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme), db: Session = Depends(get_db)) -> User:
    """Retrieve the current authenticated user."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    if credentials is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    token = credentials.credentials
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM], options={"verify_exp": True})
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        exp = payload.get("exp")
        if exp is None or datetime.utcfromtimestamp(exp) < datetime.utcnow():
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = AuthService.get_user_by_email(email, db)
    if user is None:
        raise credentials_exception
    return user

@router.post("/register", response_model=UserResponse)
def register(user: UserCreate, db: Session = Depends(get_db)):
    """Register a new user."""
    return AuthService.create_user(user, db)

@router.post("/login", response_model=Token)
def login(user: UserLogin, db: Session = Depends(get_db)):
    """Login and return a JWT token."""
    authenticated_user = AuthService.authenticate_user(user.email, user.password, db)
    if not authenticated_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = AuthService.create_access_token(
        data={"sub": authenticated_user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@router.get("/me", response_model=UserResponse)
def read_users_me(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """Get current user details with the active subscription level."""

    active_sub = db.query(Subscription).filter(
        Subscription.user_id == current_user.id,
        Subscription.expiry_date > datetime.utcnow()
    ).order_by(Subscription.expiry_date.desc()).first()

    subscription_level = active_sub.level if active_sub else None
    subscription_expires_at = active_sub.expiry_date if active_sub else None

    return {
        "id": current_user.id,
        "username": current_user.username,
        "email": current_user.email,
        "date_of_birth": current_user.date_of_birth,
        "created_at": current_user.created_at,
        "role": current_user.role,
        "subscription_level": subscription_level,
        "subscription_expires_at": subscription_expires_at
    }

@router.post("/forgot-password")
def forgot_password(email: EmailStr, db: Session = Depends(get_db)):
    return AuthService.send_password_reset(email, db)

@router.post("/reset-password")
def reset_password(token: str, new_password: str, db: Session = Depends(get_db)):
    return AuthService.reset_password(token, new_password, db)

@router.get("/verify")
def verify_email(token: str, db: Session = Depends(get_db)):
    ver_token = db.query(VerificationToken).filter(
        VerificationToken.token == token,
        VerificationToken.token_type == 'verify',
        VerificationToken.expiry > datetime.now(timezone.utc)
    ).first()
    if not ver_token:
        raise HTTPException(status_code=400, detail="Invalid or expired token")

    user = db.query(User).filter(User.id == ver_token.user_id).first()
    user.role = "user"  # Verified
    db.delete(ver_token)
    db.commit()
    return {"message": "Email verified. You can now login."}

# auth/schemas.py
# src/auth/schemas.py
from pydantic import BaseModel, EmailStr
from datetime import datetime, date
from typing import Optional

class UserCreate(BaseModel):
    """Schema for user registration."""
    username: str
    email: EmailStr
    password: str
    date_of_birth: date

class UserLogin(BaseModel):
    """Schema for user login."""
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    """Schema for user response."""
    id: int
    username: str
    email: str
    subscription_level: Optional[str] = None  # basic, pro, premium или None
    subscription_expires_at: Optional[datetime] = None  # последняя подписка
    date_of_birth: date
    created_at: datetime
    role: str

    class Config:
        from_attributes = True


class Token(BaseModel):
    """Schema for token response."""
    access_token: str
    token_type: str

class AdminActionLogResponse(BaseModel):
    """Schema for admin action log response."""
    id: int
    admin_id: int
    action: str
    timestamp: datetime

    class Config:
        from_attributes = True

# auth/services.py
# src/auth/services.py
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta, timezone
from typing import Optional
from auth.models import User, VerificationToken
from auth.schemas import UserCreate, UserResponse
from config import settings
import smtplib
from email.mime.text import MIMEText
from uuid import uuid4
from datetime import timedelta

class AuthService:
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash a password using bcrypt."""
        return AuthService.pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """Verify a password against its hash."""
        return AuthService.pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """Create a JWT access token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt

    @staticmethod
    def get_user_by_email(email: str, db: Session) -> Optional[User]:
        """Retrieve a user by email."""
        return db.query(User).filter(User.email == email).first()

    @staticmethod
    def authenticate_user(email: str, password: str, db: Session) -> Optional[User]:
        user = AuthService.get_user_by_email(email, db)
        if not user or not AuthService.verify_password(password, user.password_hash):
            return None
        if user.role == "unverified":
            raise HTTPException(status_code=403, detail="Please verify your email first")
        return user

    @staticmethod
    def create_user(user_data: UserCreate, db: Session) -> UserResponse:
        if db.query(User).filter(User.email == user_data.email).first():
            raise HTTPException(status_code=400, detail="Email already registered")
        if db.query(User).filter(User.username == user_data.username).first():
            raise HTTPException(status_code=400, detail="Username already taken")

        new_user = User(
            username=user_data.username,
            email=user_data.email,
            password_hash=AuthService.hash_password(user_data.password),
            date_of_birth=user_data.date_of_birth,
            role="unverified"  # Initial role
        )
        db.add(new_user)
        db.commit()
        db.refresh(new_user)

        # Generate verification token
        token = uuid4().hex
        expiry = datetime.now(timezone.utc) + timedelta(days=30)
        ver_token = VerificationToken(user_id=new_user.id, token=token, token_type='verify', expiry=expiry)
        db.add(ver_token)
        db.commit()

        # Send verification email
        verify_url = f"{settings.BASE_FRONT_URL}/verify?token={token}"  # Change to prod URL
        body = f"Click to verify: {verify_url}"
        AuthService.send_email(new_user.email, "Verify Your Email", body)

        return UserResponse.from_orm(new_user)

    @staticmethod
    def send_email(to_email: str, subject: str, body: str):
        msg = MIMEText(body)
        msg['Subject'] = subject
        msg['From'] = settings.FROM_EMAIL
        msg['To'] = to_email

        with smtplib.SMTP(settings.SMTP_SERVER, settings.SMTP_PORT) as server:
            server.starttls()
            server.login(settings.SMTP_USERNAME, settings.SMTP_PASSWORD)
            server.sendmail(settings.FROM_EMAIL, to_email, msg.as_string())

    @staticmethod
    def send_password_reset(email: str, db: Session):
        user = AuthService.get_user_by_email(email, db)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")

        token = uuid4().hex
        expiry = datetime.now(timezone.utc) + timedelta(days=30)
        reset_token = VerificationToken(user_id=user.id, token=token, token_type='reset', expiry=expiry)
        db.add(reset_token)
        db.commit()

        reset_url = f"{settings.BASE_FRONT_URL}/reset-password?token={token}"  # Change to prod URL
        body = f"Click to reset password: {reset_url}"
        AuthService.send_email(email, "Reset Your Password", body)
        return {"message": "Password reset email sent"}

    @staticmethod
    def reset_password(token: str, new_password: str, db: Session):
        reset_token = db.query(VerificationToken).filter(
            VerificationToken.token == token,
            VerificationToken.token_type == 'reset',
            VerificationToken.expiry > datetime.now(timezone.utc)
        ).first()
        if not reset_token:
            raise HTTPException(status_code=400, detail="Invalid or expired token")

        user = db.query(User).filter(User.id == reset_token.user_id).first()
        user.password_hash = AuthService.hash_password(new_password)
        db.delete(reset_token)
        db.commit()
        return {"message": "Password reset successful"}

# config.py
# src/config.py
from typing import Dict

class Settings:
    """Application configuration settings."""
    DATABASE_URL: str = "postgresql+psycopg2://postgres:1234@localhost:5432/mydb"
    SECRET_KEY: str = "your-secret-key-for-jwt"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24

    CDN_URL = "https://cdn.alinanightsky.com"
    GCORE_S3_DOMAIN = "s-ed1.cloud.gcore.lu"

    # GCore settings
    GCORE_BUCKET_NAME: str = "alinanightsky-website"
    GCORE_ENDPOINT_URL: str = "https://s-ed1.cloud.gcore.lu"
    GCORE_REGION_NAME: str = "s-ed1"
    GCORE_ACCESS_KEY: str = "7HQ7VZOJQXXE1M7NJ6UE"
    GCORE_SECRET_KEY: str = "t4A7iTsstPAlS3rpmdkMXdQbTuVseQVN09Kxuudx"

    # Blockchain settings — ТЕСТ
    TRON_FULL_NODE: str = "https://nile.trongrid.io"  # ТЕСТ
    # TRON_FULL_NODE: str = "https://api.trongrid.io"  # ПРОДАКШЕН
    TRON_WALLET_ADDRESS: str = "TAVCJF1m5XumpyZLnsUsuSCLrcmdbRA5A2"
    USDT_TRC20_ADDRESS: str = "TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf"

    BSC_FULL_NODE: str = "https://bsc-testnet.publicnode.com"  # Новый public endpoint с лучшими limits; альтернативы: "https://bsc-testnet.drpc.org/", "https://endpoints.omniatech.io/v1/bsc/testnet/public", "https://binance-testnet.rpc.thirdweb.com/"
    # BSC_FULL_NODE: str = "https://bsc-dataseed.binance.org"  # ПРОДАКШЕН
    BSC_WALLET_ADDRESS: str = "0x83aEb84f08517560dEBFc7F9652d8d260C921561"
    USDT_BEP20_ADDRESS: str = "0x5c24528E2c29988f696dF755C2f9951AC6D67AEF"
    USDT_BEP20_DECIMALS: int = 18  # Для теста; изменить на 18 для продакшена (стандартный USDT BEP20)

    # Subscription settings
    SUBSCRIPTION_PRICES: Dict[str, float] = {
        "basic": 10.0,
        "pro": 15.0,
        "premium": 20.0
    }
    SUBSCRIPTION_DURATION_DAYS: int = 30

    # Discount settings
    ENABLE_LOYALTY_DISCOUNT: bool = False
    SMTP_SERVER: str = "smtp.zoho.eu"
    SMTP_PORT: int = 587
    SMTP_USERNAME: str = "support@alinanightsky.com"  # Zoho email
    SMTP_PASSWORD: str = "063783qpL!"  # App password or regular
    FROM_EMAIL: str = "support@alinanightsky.com"

    BASE_URL: str = "http://localhost:8000"
    BASE_FRONT_URL: str = "http://localhost:5173"  # Frontend URL for email links, change to prod


settings = Settings()

# content/models.py
# src/content/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, Text, Boolean, DateTime, UniqueConstraint
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime
from typing import Optional

class Post(Base):
    """Represents a media post created by an admin."""
    __tablename__ = "posts"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    media_url: str = Column(String, nullable=False)
    media_type: str = Column(String, nullable=False)  # image, video, gif
    description: Optional[str] = Column(Text, nullable=True)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)
    is_visible: bool = Column(Boolean, nullable=False, default=True)
    content_type: str = Column(String, nullable=False, default="basic")  # fresh, archive, hard

    user = relationship("User", back_populates="posts")
    comments = relationship("Comment", back_populates="post")
    likes_rel = relationship("PostLike", back_populates="post")

class Comment(Base):
    """Represents a user comment on a post."""
    __tablename__ = "comments"

    id: int = Column(Integer, primary_key=True, index=True)
    post_id: int = Column(Integer, ForeignKey("posts.id"), nullable=False)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    content: str = Column(Text, nullable=False)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="comments")
    user = relationship("User", back_populates="comments")


class PostLike(Base):
    __tablename__ = "post_likes"

    id: int = Column(Integer, primary_key=True, index=True)
    post_id: int = Column(Integer, ForeignKey("posts.id"), nullable=False)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="likes_rel")
    user = relationship("User")

    __table_args__ = (UniqueConstraint('post_id', 'user_id', name='unique_post_user_like'),)

# content/routes.py
# src/content/routes.py
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.orm import Session
from typing import List
from content.services import PostService, CommentService
from content.models import Post, Comment
from content.schemas import PostCreate, PostResponse, CommentCreate, CommentResponse
from auth.routes import get_current_user
from database import get_db
from auth.models import User
from typing import Optional
from subscription.models import Subscription

router = APIRouter(prefix="/content", tags=["content"])

def check_admin_role(current_user: User = Depends(get_current_user)) -> User:
    """Ensure the user has admin role."""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user

@router.post("/posts", response_model=PostResponse, dependencies=[Depends(check_admin_role)])
async def create_post(
    file: UploadFile = File(...),
    media_type: str = "image",
    content_type: str = "fresh",
    description: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> PostResponse:
    """Create a new post with media uploaded to GCore."""
    return await PostService.create_post(
        file=file,
        media_type=media_type,
        content_type=content_type,
        description=description,
        user_id=current_user.id,
        db=db
    )

@router.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)) -> PostResponse:
    """Retrieve a post by ID."""
    post = PostService.get_post(post_id, db)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@router.put("/posts/{post_id}", response_model=PostResponse, dependencies=[Depends(check_admin_role)])
async def update_post(
    post_id: int,
    post_data: PostCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> PostResponse:
    """Update a post."""
    post = PostService.update_post(post_id, post_data, db)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@router.delete("/posts/{post_id}", dependencies=[Depends(check_admin_role)])
async def delete_post(
    post_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> dict:
    """Delete a post."""
    if not PostService.delete_post(post_id, db):
        raise HTTPException(status_code=404, detail="Post not found")
    return {"message": "Post deleted"}

@router.patch("/posts/{post_id}/visibility", response_model=PostResponse, dependencies=[Depends(check_admin_role)])
async def toggle_post_visibility(
    post_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> PostResponse:
    """Toggle post visibility."""
    post = PostService.toggle_visibility(post_id, db)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return post


@router.get("/posts", response_model=List[PostResponse])
async def get_posts(
        user_id: Optional[int] = None,
        content_type: Optional[str] = None,
        media_type: Optional[str] = None,
        limit: int = 10,
        offset: int = 0,
        db: Session = Depends(get_db),
        current_user: User = Depends(get_current_user)
) -> List[PostResponse]:
    """Retrieve posts with subscription-based access and pagination."""
    if current_user.role == "admin":
        return PostService.get_posts(user_id, content_type, media_type, db, limit, offset)

    active_sub = db.query(Subscription).filter(
        Subscription.user_id == current_user.id,
        Subscription.expiry_date > datetime.utcnow()
    ).first()

    user_level = active_sub.level if active_sub else None
    if not user_level:
        raise HTTPException(status_code=403, detail="No active subscription")

    if content_type == "archive" and user_level not in ["pro", "premium"]:
        raise HTTPException(status_code=403, detail="Upgrade to Pro or Premium")
    if content_type == "hard" and user_level != "premium":
        raise HTTPException(status_code=403, detail="Upgrade to Premium")

    return PostService.get_posts(user_id, content_type, media_type, db, limit, offset)

@router.post("/posts/{post_id}/comments", response_model=CommentResponse)
async def create_comment(
    post_id: int,
    comment_data: CommentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> CommentResponse:
    """Create a comment on a post."""
    return CommentService.create_comment(post_id, comment_data, current_user.id, db)

@router.get("/posts/{post_id}/comments", response_model=List[CommentResponse])
async def get_comments(post_id: int, db: Session = Depends(get_db)) -> List[CommentResponse]:
    """Retrieve comments for a post."""
    return CommentService.get_comments(post_id, db)

@router.put("/comments/{comment_id}", response_model=CommentResponse)
async def update_comment(
    comment_id: int,
    comment_data: CommentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> CommentResponse:
    """Update a comment."""
    comment = CommentService.update_comment(comment_id, comment_data, current_user.id, db)
    if not comment:
        raise HTTPException(status_code=404, detail="Comment not found")
    return comment

@router.delete("/comments/{comment_id}")
async def delete_comment(
    comment_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Delete a comment."""
    if not CommentService.delete_comment(comment_id, current_user.id, db):
        raise HTTPException(status_code=404, detail="Comment not found")
    return {"message": "Comment deleted"}

@router.post("/posts/{post_id}/like")
async def like_post(
    post_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Like a post."""
    return PostService.like_post(post_id, current_user.id, db)

# content/schemas.py
# src/content/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from config import settings

class PostCreate(BaseModel):
    """Schema for creating a post."""
    media_url: str
    media_type: str  # image, video, gif
    description: Optional[str] = None
    content_type: str = "basic"  # fresh, archive, hard



def s3_to_cdn(url: str) -> str:
    """Convert S3 URL to CDN URL"""
    if not url:
        return url
    return url.replace(f"https://{settings.GCORE_S3_DOMAIN}", settings.CDN_URL)


class PostResponse(BaseModel):
    """Schema for post response."""
    id: int
    user_id: int
    media_url: str # CDN URL
    media_type: str
    description: Optional[str]
    likes: int
    created_at: datetime
    is_visible: bool
    content_type: str # fresh, archive, hard

    @classmethod
    def from_orm(cls, obj):
        # НЕ используй super().from_orm(obj) → он не знает про likes_rel
        return cls(
            id=obj.id,
            user_id=obj.user_id,
            media_url=s3_to_cdn(obj.media_url),
            media_type=obj.media_type,
            description=obj.description,
            created_at=obj.created_at,
            is_visible=obj.is_visible,
            content_type=obj.content_type,
            likes=len(obj.likes_rel)  # ← ВЫЧИСЛЯЕМ ЗДЕСЬ
        )

    class Config:
        from_attributes = True

class CommentCreate(BaseModel):
    """Schema for creating a comment."""
    content: str

class CommentResponse(BaseModel):
    id: int
    post_id: int
    user_id: int
    username: str
    content: str
    created_at: datetime

    @classmethod
    def from_orm(cls, obj):
        return cls(
            id=obj.id,
            post_id=obj.post_id,
            user_id=obj.user_id,
            username=obj.user.username,
            content=obj.content,
            created_at=obj.created_at,
        )

    class Config:
        from_attributes = True

# content/services.py
# src/content/services.py
import hashlib
import hmac
import aiofiles
import logging
import mimetypes
import os
import shutil
import tempfile
import urllib.parse
import requests
from fastapi import HTTPException, UploadFile
from sqlalchemy.orm import Session, joinedload
from datetime import datetime
from typing import Optional, List
from content.models import Post, Comment, PostLike
from content.schemas import PostCreate, PostResponse, CommentCreate, CommentResponse
from config import settings

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PostService:
    @staticmethod
    async def create_post(
            file: UploadFile,
            media_type: str,
            content_type: str,
            description: Optional[str],
            user_id: int,
            db: Session
    ) -> PostResponse:
        """Create a new post with media uploaded to GCore."""
        if content_type not in ["basic", "pro", "premium"]:
            raise HTTPException(status_code=400, detail="Invalid content_type")
        if media_type not in ["image", "video", "gif"]:
            raise HTTPException(status_code=400, detail="Invalid media_type")

        mime_type, _ = mimetypes.guess_type(file.filename)
        if not mime_type or not (mime_type.startswith("image/") or mime_type.startswith("video/")):
            raise HTTPException(status_code=400, detail="File must be an image, video, or gif")

        file.file.seek(0, 2)
        file_size = file.file.tell()
        file.file.seek(0)
        if file_size > 4 * 1024 * 1024 * 1024:
            raise HTTPException(status_code=400, detail="File size exceeds 4GB")

        with tempfile.NamedTemporaryFile(delete=False, suffix=f"_{file.filename}") as temp_file:
            temp_file_path = temp_file.name
            shutil.copyfileobj(file.file, temp_file)

        try:
            file_key = f"media/{user_id}/{datetime.utcnow().timestamp()}_{urllib.parse.quote(file.filename)}"
            cdn_url = await PostService._upload_to_gcore(temp_file_path, file_key,
                                                         mime_type or "application/octet-stream")

            db_post = Post(
                user_id=user_id,
                media_url=cdn_url,
                media_type=media_type,
                content_type=content_type,
                description=description,
                is_visible=True
            )
            db.add(db_post)
            db.commit()
            db.refresh(db_post)
            return PostResponse.from_orm(db_post)
        finally:
            if os.path.exists(temp_file_path):
                os.remove(temp_file_path)

    @staticmethod
    async def _upload_to_gcore(file_path: str, file_key: str, mime_type: str) -> str:
        """Upload file to GCore and return CDN URL."""
        method = 'PUT'
        service = 's3'
        region = settings.GCORE_REGION_NAME
        host = f"{settings.GCORE_BUCKET_NAME}.s-ed1.cloud.gcore.lu"
        canonical_uri = f"/{file_key}"
        querystring = ''
        amz_date = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
        date_stamp = datetime.utcnow().strftime('%Y%m%d')
        payload_hash = PostService._calculate_payload_hash(file_path)
        headers = PostService._create_auth_headers(
            method, service, region, host, canonical_uri, querystring, payload_hash,
            settings.GCORE_ACCESS_KEY, settings.GCORE_SECRET_KEY, mime_type, amz_date, date_stamp,
            os.path.getsize(file_path)
        )
        url = f"https://{host}{canonical_uri}"
        with open(file_path, 'rb') as f:
            response = requests.put(url, data=f, headers=headers)
        if response.status_code != 200:
            logger.error(f"GCore upload failed: {response.status_code} - {response.text}")
            raise HTTPException(status_code=500,
                                detail=f"GCore upload failed: {response.status_code} - {response.text}")
        return f"{settings.GCORE_ENDPOINT_URL}/{settings.GCORE_BUCKET_NAME}/{file_key}"

    @staticmethod
    def _calculate_payload_hash(file_path: str) -> str:
        """Calculate SHA256 hash of file content."""
        sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            while chunk := f.read(8192):
                sha256.update(chunk)
        return sha256.hexdigest()

    @staticmethod
    def _create_auth_headers(
            method: str, service: str, region: str, host: str, canonical_uri: str, querystring: str,
            payload_hash: str, access_key: str, secret_key: str, content_type: str, amz_date: str, date_stamp: str,
            file_size: int
    ) -> dict:
        """Create AWS Signature V4 headers for GCore upload."""
        def sign(key, msg):
            return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()

        def get_signature_key(key, date_stamp, region_name, service_name):
            k_date = sign(('AWS4' + key).encode('utf-8'), date_stamp)
            k_region = sign(k_date, region_name)
            k_service = sign(k_region, service_name)
            k_signing = sign(k_service, 'aws4_request')
            return k_signing

        canonical_headers = f"host:{host}\nx-amz-content-sha256:{payload_hash}\nx-amz-date:{amz_date}\n"
        signed_headers = 'host;x-amz-content-sha256;x-amz-date'
        canonical_request = f'{method}\n{canonical_uri}\n{querystring}\n{canonical_headers}\n{signed_headers}\n{payload_hash}'
        algorithm = 'AWS4-HMAC-SHA256'
        credential_scope = f'{date_stamp}/{region}/{service}/aws4_request'
        string_to_sign = f'{algorithm}\n{amz_date}\n{credential_scope}\n{hashlib.sha256(canonical_request.encode("utf-8")).hexdigest()}'
        signing_key = get_signature_key(secret_key, date_stamp, region, service)
        signature = hmac.new(signing_key, string_to_sign.encode('utf-8'), hashlib.sha256).hexdigest()
        authorization_header = f'{algorithm} Credential={access_key}/{credential_scope}, SignedHeaders={signed_headers}, Signature={signature}'
        headers = {
            'Authorization': authorization_header,
            'x-amz-content-sha256': payload_hash,
            'x-amz-date': amz_date,
            'Content-Type': content_type,
            'Content-Length': str(file_size)
        }
        return headers

    @staticmethod
    def get_post(post_id: int, db: Session) -> Optional[PostResponse]:
        """Retrieve a post by ID."""
        post = db.query(Post).filter(Post.id == post_id).first()
        return PostResponse.from_orm(post) if post else None

    @staticmethod
    def update_post(post_id: int, post_data: PostCreate, db: Session) -> Optional[PostResponse]:
        """Update a post."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            return None
        if post_data.content_type not in ["basic", "pro", "premium"]:
            raise HTTPException(status_code=400, detail="Invalid content_type")
        if post_data.media_type not in ["image", "video", "gif"]:
            raise HTTPException(status_code=400, detail="Invalid media_type")
        db_post.media_url = post_data.media_url
        db_post.media_type = post_data.media_type
        db_post.description = post_data.description
        db_post.content_type = post_data.content_type
        db.commit()
        db.refresh(db_post)
        return PostResponse.from_orm(db_post)

    @staticmethod
    def delete_post(post_id: int, db: Session) -> bool:
        """Delete a post and its GCore media."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            return False
        file_key = db_post.media_url.replace(f"{settings.GCORE_ENDPOINT_URL}/{settings.GCORE_BUCKET_NAME}/", "")
        method = 'DELETE'
        service = 's3'
        region = settings.GCORE_REGION_NAME
        host = f"{settings.GCORE_BUCKET_NAME}.s-ed1.cloud.gcore.lu"
        canonical_uri = f"/{file_key}"
        querystring = ''
        amz_date = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
        date_stamp = datetime.utcnow().strftime('%Y%m%d')
        payload_hash = hashlib.sha256(b'').hexdigest()
        headers = PostService._create_auth_headers(
            method, service, region, host, canonical_uri, querystring, payload_hash,
            settings.GCORE_ACCESS_KEY, settings.GCORE_SECRET_KEY, None, amz_date, date_stamp, 0
        )
        url = f"https://{host}{canonical_uri}"
        response = requests.delete(url, headers=headers)
        if response.status_code != 204:
            logger.error(f"GCore delete failed: {response.status_code} - {response.text}")
            raise HTTPException(status_code=500,
                                detail=f"GCore delete failed: {response.status_code} - {response.text}")
        db.delete(db_post)
        db.commit()
        return True

    @staticmethod
    def toggle_visibility(post_id: int, db: Session) -> Optional[PostResponse]:
        """Toggle post visibility."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            return None
        db_post.is_visible = not db_post.is_visible
        db.commit()
        db.refresh(db_post)
        return PostResponse.from_orm(db_post)

    @staticmethod
    def get_posts(
            user_id: Optional[int],
            content_type: Optional[str],
            media_type: Optional[str],
            db: Session,
            limit: int = 10,
            offset: int = 0
    ) -> List[PostResponse]:
        """Retrieve posts with filters, pagination, and sorting."""
        query = db.query(Post).options(joinedload(Post.likes_rel))

        if user_id:
            query = query.filter(Post.user_id == user_id)
        if content_type:
            query = query.filter(Post.content_type == content_type)
        if media_type:
            query = query.filter(Post.media_type == media_type)

        # СОРТИРОВКА: НОВЫЕ СВЕРХУ
        query = query.order_by(Post.created_at.desc())

        # ПАГИНАЦИЯ
        posts = query.limit(limit).offset(offset).all()

        return [PostResponse.from_orm(post) for post in posts]

    @staticmethod
    def like_post(post_id: int, user_id: int, db: Session) -> dict:
        """Like a post (one per user)."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            raise HTTPException(status_code=404, detail="Post not found")

        # Проверяем, не лайкнул ли уже
        existing_like = db.query(PostLike).filter(
            PostLike.post_id == post_id,
            PostLike.user_id == user_id
        ).first()

        if existing_like:
            raise HTTPException(status_code=400, detail="Already liked")

        # Создаём лайк
        db_like = PostLike(post_id=post_id, user_id=user_id)
        db.add(db_like)
        db.commit()

        return {"message": "Post liked"}

class CommentService:
    @staticmethod
    def create_comment(post_id: int, comment_data: CommentCreate, user_id: int, db: Session) -> CommentResponse:
        """Create a comment on a post."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            raise HTTPException(status_code=404, detail="Post not found")
        db_comment = Comment(
            post_id=post_id,
            user_id=user_id,
            content=comment_data.content
        )
        db.add(db_comment)
        db.commit()
        db.refresh(db_comment)
        return CommentResponse.from_orm(db_comment)

    @staticmethod
    def get_comments(post_id: int, db: Session) -> List[CommentResponse]:
        """Retrieve comments for a post with username."""
        comments = (
            db.query(Comment)
            .options(joinedload(Comment.user))  # ← ДОБАВИТЬ!
            .filter(Comment.post_id == post_id)
            .all()
        )
        for c in comments:
            print(
                f"Comment {c.id}: user_id={c.user_id}, user={c.user}, username={c.user.username if c.user else 'NO USER'}")
        return [CommentResponse.from_orm(c) for c in comments]

    @staticmethod
    def update_comment(comment_id: int, comment_data: CommentCreate, user_id: int, db: Session) -> Optional[CommentResponse]:
        """Update a comment."""
        db_comment = db.query(Comment).filter(Comment.id == comment_id, Comment.user_id == user_id).first()
        if not db_comment:
            return None
        db_comment.content = comment_data.content
        db.commit()
        db.refresh(db_comment)
        return CommentResponse.from_orm(db_comment)

    @staticmethod
    def delete_comment(comment_id: int, user_id: int, db: Session) -> bool:
        """Delete a comment."""
        db_comment = db.query(Comment).filter(Comment.id == comment_id, Comment.user_id == user_id).first()
        if not db_comment:
            return False
        db.delete(db_comment)
        db.commit()
        return True

# database.py
# src/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from config import settings

# Create the database engine
engine = create_engine(settings.DATABASE_URL)

# Create a session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

def get_db():
    """Provide a database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# database_connection_check.py

from sqlalchemy import create_engine, text

connection_string = "postgresql+psycopg2://postgres:1234@localhost:5432/mydb"

try:
    engine = create_engine(connection_string)
    with engine.connect() as connection:
        result = connection.execute(text("SELECT version();"))
        version = result.fetchone()[0]
        print("✅ Подключение успешно!")
        print(f"PostgreSQL версия: {version}")
        
        # Проверка существования базы данных
        result = connection.execute(text("SELECT current_database();"))
        db_name = result.fetchone()[0]
        print(f"Текущая БД: {db_name}")
        
except Exception as e:
    print(f"❌ Ошибка подключения: {e}")


# main.py
# src/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from auth.routes import router as auth_router
from content.routes import router as content_router
from subscription.routes import router as subscription_router
from payment.routes import router as payment_router
from admin.routes import router as admin_router
from scheduler.tasks import start_scheduler, check_pending_payments

app = FastAPI(
    title="Content Site Backend",
    description="API for content site with media streaming",
    version="0.1.0",
)

# Configure CORS
origins = ["http://localhost:5173", "http://localhost", "http://127.0.0.1:5173"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth_router)
app.include_router(content_router)
app.include_router(subscription_router)
app.include_router(payment_router)
app.include_router(admin_router)

@app.on_event("startup")
async def startup_event():
    """Run initial tasks on startup."""
    check_pending_payments()
    start_scheduler()

@app.get("/")
async def root():
    """Root endpoint."""
    return {"message": "Welcome to Content Site Backend!"}

# migrations/env.py
# migrations/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
from database import Base
from auth.models import User, AdminActionLog
from content.models import Post, Comment
from subscription.models import Subscription
from payment.models import Payment, Discount

config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

config.set_main_option("sqlalchemy.url", "postgresql+psycopg2://postgres:1234@localhost:5432/mydb")
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
        )
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# migrations/versions/03bb9184cf11_add_verification_token.py
"""add verification_token

Revision ID: 03bb9184cf11
Revises: b524a7951f8f
Create Date: 2025-11-28 02:37:14.895984

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '03bb9184cf11'
down_revision: Union[str, None] = 'b524a7951f8f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('verification_tokens',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('token', sa.String(), nullable=False),
    sa.Column('token_type', sa.String(), nullable=False),
    sa.Column('expiry', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('token')
    )
    op.create_index(op.f('ix_verification_tokens_id'), 'verification_tokens', ['id'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_verification_tokens_id'), table_name='verification_tokens')
    op.drop_table('verification_tokens')
    # ### end Alembic commands ###


# migrations/versions/43543ba33103_initial_migration.py
"""Initial migration

Revision ID: 43543ba33103
Revises: 
Create Date: 2025-07-30 01:43:53.307686

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '43543ba33103'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password_hash', sa.String(), nullable=False),
    sa.Column('subscription_level', sa.String(), nullable=True),
    sa.Column('date_of_birth', sa.Date(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('role', sa.String(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)
    op.create_table('admin_action_logs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('admin_id', sa.Integer(), nullable=False),
    sa.Column('action', sa.String(), nullable=False),
    sa.Column('timestamp', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['admin_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_admin_action_logs_id'), 'admin_action_logs', ['id'], unique=False)
    op.create_table('discounts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('discount_type', sa.String(), nullable=False),
    sa.Column('discount_percentage', sa.Integer(), nullable=False),
    sa.Column('code', sa.String(), nullable=True),
    sa.Column('valid_until', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_discounts_id'), 'discounts', ['id'], unique=False)
    op.create_table('posts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('media_url', sa.String(), nullable=False),
    sa.Column('media_type', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('likes', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('is_visible', sa.Boolean(), nullable=False),
    sa.Column('content_type', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_posts_id'), 'posts', ['id'], unique=False)
    op.create_table('subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('level', sa.String(), nullable=False),
    sa.Column('expiry_date', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_subscriptions_id'), 'subscriptions', ['id'], unique=False)
    op.create_table('comments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('content', sa.Text(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_comments_id'), 'comments', ['id'], unique=False)
    op.create_table('payments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('subscription_id', sa.Integer(), nullable=False),
    sa.Column('discount_id', sa.Integer(), nullable=True),
    sa.Column('payment_method', sa.String(), nullable=False),
    sa.Column('payment_id', sa.String(), nullable=True),
    sa.Column('transaction_id', sa.String(), nullable=True),
    sa.Column('amount', sa.Integer(), nullable=False),
    sa.Column('currency', sa.String(), nullable=False),
    sa.Column('payout_currency', sa.String(), nullable=True),
    sa.Column('discount_applied', sa.Integer(), nullable=True),
    sa.Column('status', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('expiration_time', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['discount_id'], ['discounts.id'], ),
    sa.ForeignKeyConstraint(['subscription_id'], ['subscriptions.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_payments_id'), 'payments', ['id'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_payments_id'), table_name='payments')
    op.drop_table('payments')
    op.drop_index(op.f('ix_comments_id'), table_name='comments')
    op.drop_table('comments')
    op.drop_index(op.f('ix_subscriptions_id'), table_name='subscriptions')
    op.drop_table('subscriptions')
    op.drop_index(op.f('ix_posts_id'), table_name='posts')
    op.drop_table('posts')
    op.drop_index(op.f('ix_discounts_id'), table_name='discounts')
    op.drop_table('discounts')
    op.drop_index(op.f('ix_admin_action_logs_id'), table_name='admin_action_logs')
    op.drop_table('admin_action_logs')
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_index(op.f('ix_users_id'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    # ### end Alembic commands ###


# migrations/versions/4b229703b1ae_add_post_likes_table.py
"""add post_likes table

Revision ID: 4b229703b1ae
Revises: 8991e85ac8c3
Create Date: 2025-11-07 00:20:27.977788

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '4b229703b1ae'
down_revision: Union[str, None] = '8991e85ac8c3'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('post_likes',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('post_id', 'user_id', name='unique_post_user_like')
    )
    op.create_index(op.f('ix_post_likes_id'), 'post_likes', ['id'], unique=False)
    op.drop_column('posts', 'likes')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('posts', sa.Column('likes', sa.INTEGER(), autoincrement=False, nullable=True))
    op.drop_index(op.f('ix_post_likes_id'), table_name='post_likes')
    op.drop_table('post_likes')
    # ### end Alembic commands ###


# migrations/versions/8991e85ac8c3_drop_subscription_level_from_users.py
"""drop subscription_level from users

Revision ID: 8991e85ac8c3
Revises: 43543ba33103
Create Date: 2025-10-30 02:52:19.556546

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '8991e85ac8c3'
down_revision: Union[str, None] = '43543ba33103'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'subscription_level')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('subscription_level', sa.VARCHAR(), autoincrement=False, nullable=True))
    # ### end Alembic commands ###


# migrations/versions/b524a7951f8f_payment_subscription_refactor.py
"""payment_subscription_refactor

Revision ID: b524a7951f8f
Revises: 4b229703b1ae
Create Date: 2025-11-11 02:19:37.058864

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b524a7951f8f'
down_revision: Union[str, None] = '4b229703b1ae'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Добавляем новые столбцы с nullable=True где нужно
    op.add_column('payments', sa.Column('user_id', sa.Integer(), nullable=True))
    op.add_column('payments', sa.Column('purpose', sa.String(), nullable=True))
    op.add_column('payments', sa.Column('level', sa.String(), nullable=True))
    op.add_column('payments', sa.Column('client_payment_id', sa.String(), nullable=True))

    # Обновляем данные
    op.execute('UPDATE payments SET user_id = (SELECT user_id FROM subscriptions WHERE subscriptions.id = payments.subscription_id)')
    op.execute("UPDATE payments SET purpose = 'subscription'")
    # level оставляем null для legacy
    op.execute('UPDATE payments SET client_payment_id = payment_id')

    # Делаем NOT NULL где нужно
    op.alter_column('payments', 'user_id', nullable=False)
    op.alter_column('payments', 'purpose', nullable=False)

    # Добавляем FK
    op.create_foreign_key(None, 'payments', 'users', ['user_id'], ['id'])

    # Добавляем payment_id в subscriptions
    op.add_column('subscriptions', sa.Column('payment_id', sa.Integer(), nullable=True))
    op.execute('UPDATE subscriptions SET payment_id = (SELECT id FROM payments WHERE payments.subscription_id = subscriptions.id LIMIT 1)')
    op.alter_column('subscriptions', 'payment_id', nullable=False)
    op.create_foreign_key(None, 'subscriptions', 'payments', ['payment_id'], ['id'])

    # Удаляем старые столбцы
    op.drop_constraint('payments_subscription_id_fkey', 'payments', type_='foreignkey')
    op.drop_column('payments', 'subscription_id')
    op.drop_column('payments', 'discount_applied')
    op.drop_column('payments', 'payout_currency')
    op.drop_column('payments', 'payment_id')
    # ### end Alembic commands ###


def downgrade() -> None:
    # Восстанавливаем старые столбцы
    op.add_column('payments', sa.Column('payment_id', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.add_column('payments', sa.Column('payout_currency', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.add_column('payments', sa.Column('discount_applied', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('payments', sa.Column('subscription_id', sa.INTEGER(), autoincrement=False, nullable=True))

    # Обновляем данные обратно
    op.execute('UPDATE payments SET payment_id = client_payment_id')
    # subscription_id, discount_applied, payout_currency - assume defaults or manual

    op.alter_column('payments', 'subscription_id', nullable=False)

    # Восстанавливаем FK
    op.drop_constraint(None, 'payments', type_='foreignkey')
    op.create_foreign_key('payments_subscription_id_fkey', 'payments', 'subscriptions', ['subscription_id'], ['id'])

    # Удаляем новые столбцы
    op.drop_column('payments', 'client_payment_id')
    op.drop_column('payments', 'level')
    op.drop_column('payments', 'purpose')
    op.drop_column('payments', 'user_id')

    # Удаляем payment_id из subscriptions
    op.drop_constraint(None, 'subscriptions', type_='foreignkey')
    op.drop_column('subscriptions', 'payment_id')
    # ### end Alembic commands ###

# payment/models.py
# src/payment/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class Payment(Base):
    """Represents a payment."""
    __tablename__ = "payments"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)  # ← ДОБАВИЛИ
    purpose: str = Column(String, nullable=False, default="subscription")  # ← ДОБАВИЛИ (e.g. "subscription", "donation")
    level: str = Column(String, nullable=True)  # ← ДОБАВИЛИ (basic/pro/premium, only if purpose=="subscription")
    discount_id: int = Column(Integer, ForeignKey("discounts.id"), nullable=True)
    payment_method: str = Column(String, nullable=False)
    client_payment_id: str = Column(String, nullable=True)  # ← ПЕРЕИМЕНОВАЛИ payment_id
    transaction_id: str = Column(String, nullable=True)
    amount: int = Column(Integer, nullable=False)
    currency: str = Column(String, nullable=False)
    # УБРАЛИ payout_currency, discount_applied, subscription_id
    status: str = Column(String, default="pending")  # pending, confirmed, expired, failed
    created_at: datetime = Column(DateTime, default=datetime.utcnow)
    expiration_time: datetime = Column(DateTime, nullable=False)

    user = relationship("User", back_populates="payments")  # ← ДОБАВИЛИ
    discount = relationship("Discount", back_populates="payments")

class Discount(Base):
    """Represents a discount for payments."""
    __tablename__ = "discounts"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=True)
    discount_type: str = Column(String, nullable=False)
    discount_percentage: int = Column(Integer, nullable=False)
    code: str = Column(String, nullable=True)
    valid_until: datetime = Column(DateTime, nullable=True)
    is_active: bool = Column(Boolean, default=True)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="discounts")
    payments = relationship("Payment", back_populates="discount")

# payment/routes.py
# src/payment/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from payment.services import PaymentService
from payment.schemas import PaymentResponse, DiscountCreate, DiscountResponse, PaymentCheckResponse
from payment.models import Payment
from auth.routes import get_current_user
from auth.models import User
from database import get_db
from datetime import datetime
from config import settings

router = APIRouter(prefix="/payments", tags=["payments"])

def check_admin_role(current_user: User = Depends(get_current_user)) -> User:
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user

@router.get("/check-payment/{client_payment_id}", response_model=PaymentCheckResponse)
def check_payment(
    client_payment_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Check payment status and return full UX info."""
    payment = db.query(Payment).filter(Payment.client_payment_id == client_payment_id).first()
    if not payment:
        raise HTTPException(status_code=404, detail="Payment not found")

    if payment.status == "pending" and datetime.utcnow() > payment.expiration_time:
        payment.status = "expired"
        db.commit()

    if payment.status == "pending":
        payment_service = PaymentService()
        if payment_service.check_payment(payment, db):
            payment_service.confirm_payment(payment, db)
            payment.status = "confirmed"
            db.commit()

    time_left = 0
    if payment.status == "pending":
        time_left = max(0, int((payment.expiration_time - datetime.utcnow()).total_seconds()))

    if payment.currency == "usdttrc20":
        payment_url = settings.TRON_WALLET_ADDRESS
    elif payment.currency == "usdtbep20":
        payment_url = settings.BSC_WALLET_ADDRESS
    else:
        payment_url = ""

    return PaymentCheckResponse(
        status=payment.status,
        amount=payment.amount / 100.0,
        currency=payment.currency,
        payment_url=payment_url,
        expires_at=payment.expiration_time,
        time_left_seconds=time_left
    )

@router.get("/", response_model=List[PaymentResponse])
def get_user_payments(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    return PaymentService.get_user_payments(current_user.id, db)

@router.post("/discounts", response_model=DiscountResponse, dependencies=[Depends(check_admin_role)])
def create_discount(discount: DiscountCreate, db: Session = Depends(get_db), current_user: User = Depends(check_admin_role)):
    return PaymentService.create_discount(discount, db)

@router.put("/discounts/{discount_id}", response_model=DiscountResponse, dependencies=[Depends(check_admin_role)])
def update_discount(discount_id: int, discount_data: DiscountCreate, db: Session = Depends(get_db), current_user: User = Depends(check_admin_role)):
    discount = PaymentService.update_discount(discount_id, discount_data, db)
    if not discount:
        raise HTTPException(status_code=404, detail="Discount not found")
    return discount

@router.delete("/discounts/{discount_id}", dependencies=[Depends(check_admin_role)])
def delete_discount(discount_id: int, db: Session = Depends(get_db), current_user: User = Depends(check_admin_role)):
    if not PaymentService.delete_discount(discount_id, db):
        raise HTTPException(status_code=404, detail="Discount not found")
    return {"message": "Discount deleted"}

@router.get("/discounts", response_model=List[DiscountResponse], dependencies=[Depends(check_admin_role)])
def get_discounts(db: Session = Depends(get_db), current_user: User = Depends(check_admin_role)):
    return PaymentService.get_discounts(db)

# payment/schemas.py
# src/payment/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class PaymentResponse(BaseModel):
    """Schema for payment response."""
    id: int
    user_id: int  # ← ДОБАВИЛИ
    purpose: str  # ← ДОБАВИЛИ
    level: Optional[str]  # ← ДОБАВИЛИ
    discount_id: Optional[int]
    payment_method: str
    client_payment_id: Optional[str]  # ← ПЕРЕИМЕНОВАЛИ
    transaction_id: Optional[str]
    amount: int
    currency: str
    # УБРАЛИ payout_currency, discount_applied
    status: str
    created_at: datetime
    expiration_time: datetime

    class Config:
        from_attributes = True

class PaymentCreateResponse(BaseModel):
    """Schema for payment creation response."""
    client_payment_id: str  # ← ПЕРЕИМЕНОВАЛИ
    payment_url: str
    amount: float
    final_amount: float
    discount_info: str
    expires_at: datetime
    currency: str  # ← ДОБАВИЛИ (для фронта)

class PaymentCheckResponse(BaseModel):
    status: str
    amount: float
    currency: str
    payment_url: str
    expires_at: datetime
    time_left_seconds: int

class DiscountCreate(BaseModel):
    """Schema for creating a discount."""
    discount_type: str
    discount_percentage: int
    code: Optional[str] = None
    valid_until: Optional[datetime] = None
    is_active: bool = True

class DiscountResponse(BaseModel):
    """Schema for discount response."""
    id: int
    user_id: Optional[int]
    discount_type: str
    discount_percentage: int
    code: Optional[str]
    valid_until: Optional[datetime]
    is_active: bool
    created_at: datetime
    usage_count: int

    class Config:
        from_attributes = True

# payment/services.py
# src/payment/services.py
from web3 import Web3
from fastapi import HTTPException
from sqlalchemy.orm import Session
from datetime import datetime, timedelta, timezone
from typing import Optional, List
import requests
from uuid import uuid4
import time  # Для backoff в retry
import logging
from web3.middleware import geth_poa_middleware

from payment.models import Payment, Discount
from payment.schemas import PaymentResponse, DiscountCreate, DiscountResponse, PaymentCreateResponse
from subscription.models import Subscription
from config import settings

logger = logging.getLogger(__name__)  # Логгер для детализации ошибок и параметров

class PaymentService:
    def __init__(self):
        self.tron_wallet_address = settings.TRON_WALLET_ADDRESS
        self.bsc = Web3(Web3.HTTPProvider(settings.BSC_FULL_NODE))
        self.bsc.middleware_onion.inject(geth_poa_middleware, layer=0)
        self.bsc_wallet_address = settings.BSC_WALLET_ADDRESS
        self.usdt_trc20_address = settings.USDT_TRC20_ADDRESS
        self.usdt_bep20_address = settings.USDT_BEP20_ADDRESS
        self.usdt_bep20_abi = [
            {
                "anonymous": False,
                "inputs": [
                    {"indexed": True, "internalType": "address", "name": "from", "type": "address"},
                    {"indexed": True, "internalType": "address", "name": "to", "type": "address"},
                    {"indexed": False, "internalType": "uint256", "name": "value", "type": "uint256"}
                ],
                "name": "Transfer",
                "type": "event"
            },
            {
                "constant": True,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
                "payable": False,
                "stateMutability": "view",
                "type": "function"
            }
        ]
        self.usdt_bep20_contract = self.bsc.eth.contract(
            address=self.usdt_bep20_address,
            abi=self.usdt_bep20_abi
        )
        # Динамически получаем decimals для USDT BEP20
        try:
            self.usdt_bep20_decimals = self.usdt_bep20_contract.functions.decimals().call()
            logger.info(f"USDT BEP20 decimals: {self.usdt_bep20_decimals}")
        except Exception as e:
            logger.error(f"Error getting USDT BEP20 decimals: {str(e)}")
            self.usdt_bep20_decimals = settings.USDT_BEP20_DECIMALS  # Fallback из config

    @staticmethod
    def generate_unique_amount(final_price: float, db: Session) -> float:
        candidates = [
            final_price,
            final_price - 0.01, final_price + 0.01,
            final_price - 0.02, final_price + 0.02,
        ]
        for amount in candidates:
            if amount <= 0:
                continue
            int_amount = int(amount * 100)
            exists = db.query(Payment).filter(
                Payment.amount == int_amount,
                Payment.status == "pending",
                Payment.expiration_time > datetime.now(timezone.utc)
            ).first()
            if not exists:
                return amount
        raise HTTPException(status_code=400, detail="No available unique amount. Try again later.")

    def create_payment(self, user_id: int, purpose: str, level: Optional[str], amount: float, currency: str, db: Session) -> PaymentCreateResponse:
        if currency == "usdttrc20":
            address = self.tron_wallet_address
        elif currency == "usdtbep20":
            address = self.bsc_wallet_address
        else:
            raise HTTPException(status_code=400, detail="Unsupported currency")

        now_utc = datetime.now(timezone.utc)
        expiry_utc = now_utc + timedelta(minutes=30)
        payment = Payment(
            user_id=user_id,
            purpose=purpose,
            level=level if purpose == "subscription" else None,
            payment_method="crypto",
            client_payment_id=f"pay_{uuid4().hex[:12]}",
            amount=int(amount * 100),
            currency=currency,
            status="pending",
            expiration_time=expiry_utc.replace(tzinfo=None),  # Save naive for DB
            created_at=now_utc.replace(tzinfo=None)  # Save naive for DB
        )
        db.add(payment)
        db.commit()
        db.refresh(payment)

        return PaymentCreateResponse(
            client_payment_id=payment.client_payment_id,
            payment_url=address,
            amount=amount,
            final_amount=amount,
            discount_info="",
            expires_at=payment.expiration_time,
            currency=currency
        )

    def check_payment(self, payment: Payment, db: Session) -> bool:
        amount_in_usd = payment.amount / 100.0
        created_at_utc = payment.created_at.replace(tzinfo=timezone.utc)
        expiration_utc = payment.expiration_time.replace(tzinfo=timezone.utc)
        min_ts = int(created_at_utc.timestamp() * 1000)
        max_ts = int(expiration_utc.timestamp() * 1000)
        current_time = datetime.now(timezone.utc)

        min_dt = datetime.fromtimestamp(min_ts / 1000, tz=timezone.utc)
        max_dt = datetime.fromtimestamp(max_ts / 1000, tz=timezone.utc)

        logger.info(f"Checking payment {payment.client_payment_id}: currency={payment.currency}, expected_amount={amount_in_usd}, created_at={created_at_utc.isoformat()} (UTC), expiration_time={expiration_utc.isoformat()} (UTC), current_time={current_time.isoformat()} (UTC), min_ts={min_ts}, max_ts={max_ts}, min_dt={min_dt.isoformat()} (UTC), max_dt={max_dt.isoformat()} (UTC)")

        if payment.currency == "usdttrc20":
            url = f"{settings.TRON_FULL_NODE}/v1/accounts/{self.tron_wallet_address}/transactions/trc20"
            params = {
                "contract_address": self.usdt_trc20_address,
                "min_timestamp": min_ts,
                "max_timestamp": max_ts
            }
            logger.info(f"TRON API call: url={url}, params={params}")
            try:
                response = requests.get(url, params=params, timeout=10)
                logger.info(f"TRON API response status: {response.status_code}")
                if response.status_code != 200:
                    logger.error(f"TRON API non-200 status: {response.status_code}, text={response.text}")
                    return False
                data = response.json().get("data", [])
                logger.info(f"Found {len(data)} transactions in TRON response")
                if not data:
                    logger.info("No transactions found in API response")
                logger.info("Matching only by to and amount, trusting API filter")
                for tx in data:
                    ts = tx.get("timestamp", 0)
                    dt = datetime.fromtimestamp(ts / 1000, tz=timezone.utc).isoformat() if ts else "N/A"
                    calculated_value = float(tx.get("value", 0)) / 10 ** 6
                    logger.info(f"Tx ID: {tx.get('transaction_id')}, To: {tx.get('to')}, Raw Value: {tx.get('value')}, Calculated Value: {calculated_value}, Timestamp: {ts} ({dt} UTC), Type: {tx.get('type')}")
                    if ts != 0 and not (min_ts <= ts <= max_ts):
                        logger.info(f"API returned tx with unexpected ts {ts} ({dt} UTC) outside requested range {min_ts}-{max_ts} ({min_dt.isoformat()}-{max_dt.isoformat()} UTC)")
                        continue
                    if (tx["to"] == self.tron_wallet_address and
                            calculated_value == amount_in_usd):
                        payment.transaction_id = tx["transaction_id"]
                        db.commit()
                        logger.info(f"Matched tx {tx['transaction_id']} with amount {calculated_value}")
                        return True
                    elif calculated_value != amount_in_usd:
                        logger.info(f"Mismatched amount in tx {tx.get('transaction_id')}: calculated {calculated_value} != expected {amount_in_usd}")
            except Exception as e:
                logger.error(f"TRON API error for payment {payment.client_payment_id}: {str(e)}")
        elif payment.currency == "usdtbep20":
            latest_block = self.bsc.eth.block_number
            time_diff_sec = (max_ts - min_ts) / 1000
            blocks_to_scan = int(time_diff_sec // 3) + 1000
            from_block = max(0, latest_block - blocks_to_scan)

            try:
                latest_ts = self.bsc.eth.get_block(latest_block)['timestamp'] * 1000
                from_ts = self.bsc.eth.get_block(from_block)['timestamp'] * 1000
                logger.info(f"Scan range ts: from_ts={from_ts} to latest_ts={latest_ts}")
            except Exception as e:
                logger.error(f"Error getting block ts: {str(e)}")

            logger.info(f"BSC scan for payment {payment.client_payment_id}: from_block={from_block}, to_block={latest_block}, blocks_to_scan={blocks_to_scan}")

            chunk_size = 50
            current_block = from_block
            while current_block < latest_block:
                chunk_end = min(current_block + chunk_size, latest_block)
                for attempt in range(3):
                    time.sleep(0.5)
                    try:
                        transfer_events = self.usdt_bep20_contract.events.Transfer.get_logs(
                            fromBlock=current_block,
                            toBlock=chunk_end,
                            argument_filters={"to": self.bsc_wallet_address}
                        )
                        logger.info(f"Found {len(transfer_events)} transfer events in chunk {current_block}-{chunk_end}, attempt {attempt + 1}")
                        for event in transfer_events:
                            try:
                                block_ts = self.bsc.eth.get_block(event.blockNumber)['timestamp'] * 1000
                            except Exception as ts_e:
                                logger.error(f"Error getting block_ts for block {event.blockNumber}: {str(ts_e)}")
                                continue
                            amount_transferred = event["args"]["value"] / 10 ** self.usdt_bep20_decimals  # Используем динамические decimals
                            logger.info(f"Event tx {event['transactionHash'].hex()}, from {event['args']['from']}, to {event['args']['to']}, raw_value {event['args']['value']}, amount_transferred {amount_transferred}, block {event.blockNumber}, block_ts {block_ts}")
                            if min_ts <= block_ts <= max_ts:
                                if amount_transferred == amount_in_usd:
                                    payment.transaction_id = event["transactionHash"].hex()
                                    db.commit()
                                    logger.info(f"Payment {payment.client_payment_id} matched tx {payment.transaction_id}")
                                    return True
                                else:
                                    logger.info(f"Mismatched amount in tx {event['transactionHash'].hex()}: transferred {amount_transferred} != expected {amount_in_usd}")
                            else:
                                logger.info(f"Event outside range: tx {event['transactionHash'].hex()}, block_ts {block_ts} not in {min_ts}-{max_ts}")
                        break
                    except Exception as e:
                        logger.error(f"BSC error for payment {payment.client_payment_id} in chunk {current_block}-{chunk_end}, attempt {attempt + 1}: {str(e)}")
                        if attempt < 2:
                            sleep_time = 2 ** attempt
                            logger.info(f"Retrying chunk after {sleep_time} sec backoff")
                            time.sleep(sleep_time)
                        else:
                            return False
                current_block = chunk_end + 1
            logger.info(f"No matching events for payment {payment.client_payment_id} after scanning all chunks")
        return False

    def confirm_payment(self, payment: Payment, db: Session):
        """Confirm logic after blockchain success."""
        if payment.purpose != "subscription":
            return

        active_sub = db.query(Subscription).filter(
            Subscription.user_id == payment.user_id,
            Subscription.expiry_date > datetime.now(timezone.utc)
        ).first()

        if active_sub and active_sub.level == payment.level:
            active_sub.expiry_date += timedelta(days=settings.SUBSCRIPTION_DURATION_DAYS)
            active_sub.payment_id = payment.id
        else:
            new_sub = Subscription(
                user_id=payment.user_id,
                level=payment.level,
                expiry_date=datetime.now(timezone.utc) + timedelta(days=settings.SUBSCRIPTION_DURATION_DAYS),
                payment_id=payment.id
            )
            db.add(new_sub)
            if active_sub:
                active_sub.expiry_date = datetime.now(timezone.utc)

        db.commit()

    @staticmethod
    def get_user_payments(user_id: int, db: Session) -> List[PaymentResponse]:
        payments = db.query(Payment).filter(Payment.user_id == user_id).all()
        return [PaymentResponse.from_orm(p) for p in payments]

    @staticmethod
    def create_discount(discount_data: DiscountCreate, db: Session) -> DiscountResponse:
        db_discount = Discount(**discount_data.dict())
        db.add(db_discount)
        db.commit()
        db.refresh(db_discount)
        usage_count = db.query(Payment).filter(Payment.discount_id == db_discount.id).count()
        return DiscountResponse.from_orm(db_discount).copy(update={"usage_count": usage_count})

    @staticmethod
    def update_discount(discount_id: int, discount_data: DiscountCreate, db: Session) -> Optional[DiscountResponse]:
        db_discount = db.query(Discount).filter(Discount.id == discount_id).first()
        if not db_discount:
            return None
        for key, value in discount_data.dict().items():
            setattr(db_discount, key, value)
        db.commit()
        db.refresh(db_discount)
        usage_count = db.query(Payment).filter(Payment.discount_id == db_discount.id).count()
        return DiscountResponse.from_orm(db_discount).copy(update={"usage_count": usage_count})

    @staticmethod
    def delete_discount(discount_id: int, db: Session) -> bool:
        db_discount = db.query(Discount).filter(Discount.id == discount_id).first()
        if not db_discount:
            return False
        db.delete(db_discount)
        db.commit()
        return True

    @staticmethod
    def get_discounts(db: Session) -> List[DiscountResponse]:
        discounts = db.query(Discount).all()
        return [
            DiscountResponse.from_orm(d).copy(update={"usage_count": db.query(Payment).filter(Payment.discount_id == d.id).count()})
            for d in discounts
        ]

# py_to_txt.py
import os
import fnmatch

# === Настройки ===
OUTPUT_FILE = "project_dump.txt"  # итоговый файл
ROOT_DIR = os.getcwd()  # корень проекта
IGNORED_DIRS = {".venv", "venv", "__pycache__", ".git"}  # папки для игнора
IGNORED_FILES = {"*.pyc", "*.pyo", "*.log", "*.md", "*.json", "*.txt"}  # маски файлов для игнора


def is_empty_init(file_path):
    """Проверяет, является ли файл __init__.py пустым"""
    return os.path.basename(file_path) == "__init__.py" and os.path.getsize(file_path) == 0


def is_ignored(file_name, dir_path):
    """Проверка, игнорируется ли файл"""
    # Игнорируем по маскам
    for pattern in IGNORED_FILES:
        if fnmatch.fnmatch(file_name, pattern):
            return True
    return False


def collect_python_files(root):
    """Собирает все .py файлы, исключая игнорируемые"""
    python_files = []
    for dirpath, dirnames, filenames in os.walk(root):
        # Убираем игнорируемые директории
        dirnames[:] = [d for d in dirnames if d not in IGNORED_DIRS]
        for filename in filenames:
            if filename.endswith(".py") and not is_ignored(filename, dirpath):
                full_path = os.path.join(dirpath, filename)
                if not is_empty_init(full_path):
                    python_files.append(full_path)
    return sorted(python_files)


def relative_path(path, root):
    """Возвращает относительный путь от root"""
    return os.path.relpath(path, root).replace("\\", "/")


def build_dump(root, output_file):
    files = collect_python_files(root)
    with open(output_file, "w", encoding="utf-8") as out:
        for file_path in files:
            rel_path = relative_path(file_path, root)
            out.write(f"\n# {rel_path}\n")
            with open(file_path, "r", encoding="utf-8") as f:
                out.write(f.read())
                out.write("\n")
    print(f"Собрано {len(files)} файлов в {output_file}")


if __name__ == "__main__":
    build_dump(ROOT_DIR, OUTPUT_FILE)

# scheduler/tasks.py
# src/scheduler/tasks.py
import logging
from apscheduler.schedulers.background import BackgroundScheduler
from sqlalchemy.orm import Session
from datetime import datetime, timezone

from config import settings
from database import SessionLocal
from payment.models import Payment
from payment.services import PaymentService

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def check_pending_payments():
    """Check and update pending payments."""
    logger.info("Starting check_pending_payments task")
    db: Session = SessionLocal()
    try:
        pending_payments = db.query(Payment).filter(Payment.status == "pending").all()
        payment_service = PaymentService()
        for payment in pending_payments:
            logger.info(f"Checking payment: {payment.client_payment_id}, expiration_time: {payment.expiration_time}")
            if payment.expiration_time < datetime.now(timezone.utc).replace(tzinfo=None):
                payment.status = "expired"
                db.commit()
                logger.info(f"Payment {payment.client_payment_id} marked as expired")
                continue
            if payment_service.check_payment(payment, db):
                payment_service.confirm_payment(payment, db)
                payment.status = "confirmed"
                db.commit()
                logger.info(f"Payment {payment.client_payment_id} confirmed")
    except Exception as e:
        logger.error(f"Error in check_pending_payments: {str(e)}")
    finally:
        db.close()
    logger.info("Finished check_pending_payments task")

def archive_old_posts():
    logger.info("Starting archive_old_posts task")
    db: Session = SessionLocal()
    try:
        db.execute(
            "UPDATE posts SET content_type = 'archive' WHERE content_type = 'basic' AND created_at < NOW() - INTERVAL '1 year'"
        )
        db.commit()
        logger.info("Successfully archived old posts")
    except Exception as e:
        logger.error(f"Error in archive_old_posts: {str(e)}")
    finally:
        db.close()
    logger.info("Finished archive_old_posts task")

def start_scheduler():
    scheduler = BackgroundScheduler()
    scheduler.add_job(check_pending_payments, 'interval', minutes=5)
    scheduler.add_job(archive_old_posts, 'interval', days=1)
    scheduler.start()

# subscription/models.py
# src/subscription/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class Subscription(Base):
    """Represents a user subscription."""
    __tablename__ = "subscriptions"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    level: str = Column(String, nullable=False)
    expiry_date: datetime = Column(DateTime, nullable=False)
    payment_id: int = Column(Integer, ForeignKey("payments.id"), nullable=False)  # ← ДОБАВИЛИ (last successful payment)

    user = relationship("User", back_populates="subscriptions")
    payment = relationship("Payment")  # ← ДОБАВИЛИ (no back_populates, one-way)

# subscription/routes.py
# src/subscription/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from subscription.services import SubscriptionService
from subscription.schemas import SubscriptionCreate, SubscriptionResponse
from payment.schemas import PaymentCreateResponse
from auth.routes import get_current_user
from database import get_db
from auth.models import User

router = APIRouter(prefix="/subscriptions", tags=["subscriptions"])

@router.post("/", response_model=PaymentCreateResponse)
def create_subscription(
    subscription_data: SubscriptionCreate,
    currency: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create or extend a subscription."""
    return SubscriptionService.create_subscription(subscription_data, currency, current_user, db)

@router.get("/", response_model=List[SubscriptionResponse])
def get_user_subscriptions(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Retrieve user subscriptions."""
    return SubscriptionService.get_user_subscriptions(current_user.id, db)

# subscription/schemas.py
# src/subscription/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SubscriptionCreate(BaseModel):
    """Schema for creating a subscription."""
    level: str
    promo_code: Optional[str] = None

class SubscriptionResponse(BaseModel):
    """Schema for subscription response."""
    id: int
    user_id: int
    level: str
    expiry_date: datetime
    payment_id: int  # ← ДОБАВИЛИ

    class Config:
        from_attributes = True

# subscription/services.py
# src/subscription/services.py
from fastapi import HTTPException
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import Optional, Tuple
from subscription.models import Subscription
from subscription.schemas import SubscriptionCreate, SubscriptionResponse
from payment.schemas import PaymentCreateResponse
from payment.models import Discount
from payment.services import PaymentService
from auth.models import User
from config import settings

class SubscriptionService:
    @staticmethod
    def get_discount(promo_code: Optional[str], db: Session) -> Tuple[Optional[int], float, str]:
        if not promo_code:
            return None, 0.0, ""
        discount = db.query(Discount).filter(
            Discount.code == promo_code,
            Discount.is_active == True,
            (Discount.valid_until.is_(None) | (Discount.valid_until >= datetime.utcnow()))
        ).first()
        if discount:
            return discount.id, discount.discount_percentage / 100.0, f"Applied promo code {promo_code}, discount {discount.discount_percentage}%"
        return None, 0.0, ""

    @staticmethod
    def create_subscription(
            subscription_data: SubscriptionCreate,
            currency: str,
            user: User,
            db: Session
    ) -> PaymentCreateResponse:
        if subscription_data.level not in settings.SUBSCRIPTION_PRICES:
            raise HTTPException(status_code=400, detail="Invalid subscription level")

        today = datetime.utcnow().date()
        dob = user.date_of_birth
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
        if age < 18:
            raise HTTPException(status_code=403, detail="You must be 18 or older")

        active_sub = db.query(Subscription).filter(
            Subscription.user_id == user.id,
            Subscription.expiry_date > datetime.utcnow()
        ).first()

        base_price = settings.SUBSCRIPTION_PRICES[subscription_data.level]

        discount_id, discount_rate, discount_info = SubscriptionService.get_discount(subscription_data.promo_code, db)
        final_price = base_price * (1 - discount_rate)

        if active_sub:
            if active_sub.level == subscription_data.level:
                final_price = base_price
            elif settings.SUBSCRIPTION_PRICES[active_sub.level] > base_price:
                raise HTTPException(status_code=400, detail="Downgrade not allowed")
            else:
                final_price = base_price - settings.SUBSCRIPTION_PRICES[active_sub.level]

        payment_service = PaymentService()
        unique_amount = payment_service.generate_unique_amount(final_price, db)

        # Создаём Payment через service
        payment_resp = payment_service.create_payment(
            user_id=user.id,
            purpose="subscription",
            level=subscription_data.level,
            amount=unique_amount,
            currency=currency,
            db=db
        )

        payment_resp.discount_info = discount_info  # Добавляем, если нужно (расширяем response если discount)

        return payment_resp

    @staticmethod
    def get_user_subscriptions(user_id: int, db: Session) -> list[SubscriptionResponse]:
        subs = db.query(Subscription).filter(
            Subscription.user_id == user_id,
            Subscription.expiry_date > datetime.utcnow()
        ).all()
        return [SubscriptionResponse.from_orm(s) for s in subs]
