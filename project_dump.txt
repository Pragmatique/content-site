
# admin/routes.py
# src/admin/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List, Optional
from auth.models import User, AdminActionLog
from auth.schemas import UserResponse, AdminActionLogResponse
from content.models import Post
from content.schemas import PostResponse
from subscription.models import Subscription
from subscription.schemas import SubscriptionResponse
from payment.models import Payment, Discount
from payment.schemas import PaymentResponse, DiscountResponse
from auth.routes import get_current_user
from database import get_db

router = APIRouter(prefix="/admin", tags=["admin"])

def check_admin_role(current_user: User = Depends(get_current_user)) -> User:
    """Ensure the user has admin role."""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user

@router.get("/users", response_model=List[UserResponse], dependencies=[Depends(check_admin_role)])
def get_users(
    subscription_level: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve users with optional subscription level filter."""
    query = db.query(User)
    if subscription_level:
        query = query.filter(User.subscription_level == subscription_level)
    return [UserResponse.from_orm(user) for user in query.all()]

@router.patch("/users/{user_id}/subscription", response_model=UserResponse, dependencies=[Depends(check_admin_role)])
def update_user_subscription(
    user_id: int,
    subscription_level: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Update a user's subscription level."""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    user.subscription_level = subscription_level
    db.commit()
    db.refresh(user)
    log = AdminActionLog(admin_id=current_user.id, action=f"Updated subscription level of user {user_id} to {subscription_level}")
    db.add(log)
    db.commit()
    return UserResponse.from_orm(user)

@router.get("/posts", response_model=List[PostResponse], dependencies=[Depends(check_admin_role)])
def get_posts(
    user_id: Optional[int] = None,
    content_type: Optional[str] = None,
    media_type: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve posts with optional filters."""
    query = db.query(Post)
    if user_id:
        query = query.filter(Post.user_id == user_id)
    if content_type:
        query = query.filter(Post.content_type == content_type)
    if media_type:
        query = query.filter(Post.media_type == media_type)
    return [PostResponse.from_orm(post) for post in query.all()]

@router.get("/subscriptions", response_model=List[SubscriptionResponse], dependencies=[Depends(check_admin_role)])
def get_subscriptions(
    level: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve subscriptions with optional level filter."""
    query = db.query(Subscription)
    if level:
        query = query.filter(Subscription.level == level)
    return [SubscriptionResponse.from_orm(sub) for sub in query.all()]

@router.get("/payments", response_model=List[PaymentResponse], dependencies=[Depends(check_admin_role)])
def get_payments(
    status: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve payments with optional status filter."""
    query = db.query(Payment)
    if status:
        query = query.filter(Payment.status == status)
    return [PaymentResponse.from_orm(payment) for payment in query.all()]

@router.get("/logs", response_model=List[AdminActionLogResponse], dependencies=[Depends(check_admin_role)])
def get_admin_logs(db: Session = Depends(get_db), current_user: User = Depends(check_admin_role)):
    """Retrieve admin action logs."""
    return [AdminActionLogResponse.from_orm(log) for log in db.query(AdminActionLog).all()]

# auth/models.py
# src/auth/models.py
from sqlalchemy import Column, Integer, String, Date, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class User(Base):
    """Represents a user in the system."""
    __tablename__ = "users"

    id: int = Column(Integer, primary_key=True, index=True)
    username: str = Column(String, unique=True, index=True, nullable=False)
    email: str = Column(String, unique=True, index=True, nullable=False)
    password_hash: str = Column(String, nullable=False)
    subscription_level: str = Column(String, default="free")
    date_of_birth: datetime = Column(Date, nullable=False)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)
    role: str = Column(String, nullable=False, default="user")

    posts = relationship("Post", back_populates="user")
    comments = relationship("Comment", back_populates="user")
    subscriptions = relationship("Subscription", back_populates="user")
    discounts = relationship("Discount", back_populates="user")
    admin_actions = relationship("AdminActionLog", back_populates="admin")

class AdminActionLog(Base):
    """Represents a log of admin actions."""
    __tablename__ = "admin_action_logs"

    id: int = Column(Integer, primary_key=True, index=True)
    admin_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    action: str = Column(String, nullable=False)
    timestamp: datetime = Column(DateTime, nullable=False, default=datetime.utcnow)

    admin = relationship("User", back_populates="admin_actions")

# auth/routes.py
# src/auth/routes.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from jose import jwt, JWTError
from datetime import timedelta, datetime
from auth.services import AuthService
from auth.schemas import UserCreate, UserResponse, UserLogin, Token
from auth.models import User
from config import settings
from database import get_db

router = APIRouter(prefix="/auth", tags=["auth"])
bearer_scheme = HTTPBearer(auto_error=False)

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme), db: Session = Depends(get_db)) -> User:
    """Retrieve the current authenticated user."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    if credentials is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    token = credentials.credentials
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM], options={"verify_exp": True})
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        exp = payload.get("exp")
        if exp is None or datetime.utcfromtimestamp(exp) < datetime.utcnow():
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = AuthService.get_user_by_email(email, db)
    if user is None:
        raise credentials_exception
    return user

@router.post("/register", response_model=UserResponse)
def register(user: UserCreate, db: Session = Depends(get_db)):
    """Register a new user."""
    return AuthService.create_user(user, db)

@router.post("/login", response_model=Token)
def login(user: UserLogin, db: Session = Depends(get_db)):
    """Login and return a JWT token."""
    authenticated_user = AuthService.authenticate_user(user.email, user.password, db)
    if not authenticated_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = AuthService.create_access_token(
        data={"sub": authenticated_user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
def read_users_me(current_user: User = Depends(get_current_user)):
    """Get current user details."""
    return current_user

# auth/schemas.py
# src/auth/schemas.py
from pydantic import BaseModel, EmailStr
from datetime import datetime, date
from typing import Optional

class UserCreate(BaseModel):
    """Schema for user registration."""
    username: str
    email: EmailStr
    password: str
    date_of_birth: date

class UserLogin(BaseModel):
    """Schema for user login."""
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    """Schema for user response."""
    id: int
    username: str
    email: str
    subscription_level: str
    date_of_birth: date
    created_at: datetime
    role: str

    class Config:
        from_attributes = True

class Token(BaseModel):
    """Schema for token response."""
    access_token: str
    token_type: str

class AdminActionLogResponse(BaseModel):
    """Schema for admin action log response."""
    id: int
    admin_id: int
    action: str
    timestamp: datetime

    class Config:
        from_attributes = True

# auth/services.py
# src/auth/services.py
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import Optional
from auth.models import User
from auth.schemas import UserCreate, UserResponse
from config import settings

class AuthService:
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash a password using bcrypt."""
        return AuthService.pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """Verify a password against its hash."""
        return AuthService.pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """Create a JWT access token."""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt

    @staticmethod
    def get_user_by_email(email: str, db: Session) -> Optional[User]:
        """Retrieve a user by email."""
        return db.query(User).filter(User.email == email).first()

    @staticmethod
    def authenticate_user(email: str, password: str, db: Session) -> Optional[User]:
        """Authenticate a user by email and password."""
        user = AuthService.get_user_by_email(email, db)
        if not user or not AuthService.verify_password(password, user.password_hash):
            return None
        return user

    @staticmethod
    def create_user(user_data: UserCreate, db: Session) -> UserResponse:
        """Create a new user."""
        if db.query(User).filter(User.email == user_data.email).first():
            raise HTTPException(status_code=400, detail="Email already registered")
        if db.query(User).filter(User.username == user_data.username).first():
            raise HTTPException(status_code=400, detail="Username already taken")

        new_user = User(
            username=user_data.username,
            email=user_data.email,
            password_hash=AuthService.hash_password(user_data.password),
            date_of_birth=user_data.date_of_birth
        )
        db.add(new_user)
        db.commit()
        db.refresh(new_user)
        return UserResponse.from_orm(new_user)

# config.py
# src/config.py
from typing import Dict

    
class Settings:
    """Application configuration settings."""
    DATABASE_URL: str = "postgresql+psycopg2://postgres:1234@localhost:5433/mydb2"
    SECRET_KEY: str = "your-secret-key-for-jwt"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24

    # GCore settings
    GCORE_BUCKET_NAME: str = "alinanightsky-website"
    GCORE_ENDPOINT_URL: str = "https://s-ed1.cloud.gcore.lu"
    GCORE_REGION_NAME: str = "s-ed1"
    GCORE_ACCESS_KEY: str = "7HQ7VZOJQXXE1M7NJ6UE"
    GCORE_SECRET_KEY: str = "t4A7iTsstPAlS3rpmdkMXdQbTuVseQVN09Kxuudx"

    # Blockchain settings
    TRON_FULL_NODE: str = "https://nile.trongrid.io"
    TRON_WALLET_ADDRESS: str = "TAVCJF1m5XumpyZLnsUsuSCLrcmdbRA5A2"
    USDT_TRC20_ADDRESS: str = "TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf"
    BSC_FULL_NODE: str = "https://data-seed-prebsc-1-s1.binance.org:8545"
    BSC_WALLET_ADDRESS: str = "0x83aEb84f08517560dEBFc7F9652d8d260C921561"
    USDT_BEP20_ADDRESS: str = "0x5c24528E2c29988f696dF755C2f9951AC6D67AEF"

    # Subscription settings
    SUBSCRIPTION_PRICES: Dict[str, float] = {
        "basic": 10.0,
        "pro": 15.0,
        "premium": 20.0
    }
    SUBSCRIPTION_DURATION_DAYS: int = 30

    # Discount settings
    ENABLE_LOYALTY_DISCOUNT: bool = False


settings = Settings()


# content/models.py
# src/content/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, Text, Boolean, DateTime
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime
from typing import Optional

class Post(Base):
    """Represents a media post created by an admin."""
    __tablename__ = "posts"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    media_url: str = Column(String, nullable=False)
    media_type: str = Column(String, nullable=False)  # image, video, gif
    description: Optional[str] = Column(Text, nullable=True)
    likes: int = Column(Integer, default=0)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)
    is_visible: bool = Column(Boolean, nullable=False, default=True)
    content_type: str = Column(String, nullable=False, default="basic")  # basic, archive

    user = relationship("User", back_populates="posts")
    comments = relationship("Comment", back_populates="post")

class Comment(Base):
    """Represents a user comment on a post."""
    __tablename__ = "comments"

    id: int = Column(Integer, primary_key=True, index=True)
    post_id: int = Column(Integer, ForeignKey("posts.id"), nullable=False)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    content: str = Column(Text, nullable=False)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)

    post = relationship("Post", back_populates="comments")
    user = relationship("User", back_populates="comments")

# content/routes.py
# src/content/routes.py
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File
from sqlalchemy.orm import Session
from typing import List
from content.services import PostService, CommentService
from content.models import Post, Comment
from content.schemas import PostCreate, PostResponse, CommentCreate, CommentResponse
from auth.routes import get_current_user
from database import get_db
from auth.models import User
from typing import Optional

router = APIRouter(prefix="/content", tags=["content"])

def check_admin_role(current_user: User = Depends(get_current_user)) -> User:
    """Ensure the user has admin role."""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user

@router.post("/posts", response_model=PostResponse, dependencies=[Depends(check_admin_role)])
async def create_post(
    file: UploadFile = File(...),
    media_type: str = "image",
    content_type: str = "basic",
    description: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> PostResponse:
    """Create a new post with media uploaded to GCore."""
    return await PostService.create_post(
        file=file,
        media_type=media_type,
        content_type=content_type,
        description=description,
        user_id=current_user.id,
        db=db
    )

@router.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)) -> PostResponse:
    """Retrieve a post by ID."""
    post = PostService.get_post(post_id, db)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@router.put("/posts/{post_id}", response_model=PostResponse, dependencies=[Depends(check_admin_role)])
async def update_post(
    post_id: int,
    post_data: PostCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> PostResponse:
    """Update a post."""
    post = PostService.update_post(post_id, post_data, db)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@router.delete("/posts/{post_id}", dependencies=[Depends(check_admin_role)])
async def delete_post(
    post_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> dict:
    """Delete a post."""
    if not PostService.delete_post(post_id, db):
        raise HTTPException(status_code=404, detail="Post not found")
    return {"message": "Post deleted"}

@router.patch("/posts/{post_id}/visibility", response_model=PostResponse, dependencies=[Depends(check_admin_role)])
async def toggle_post_visibility(
    post_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
) -> PostResponse:
    """Toggle post visibility."""
    post = PostService.toggle_visibility(post_id, db)
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@router.get("/posts", response_model=List[PostResponse])
async def get_posts(
    user_id: Optional[int] = None,
    content_type: Optional[str] = None,
    media_type: Optional[str] = None,
    db: Session = Depends(get_db)
) -> List[PostResponse]:
    """Retrieve posts with optional filters."""
    return PostService.get_posts(user_id, content_type, media_type, db)

@router.post("/posts/{post_id}/comments", response_model=CommentResponse)
async def create_comment(
    post_id: int,
    comment_data: CommentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> CommentResponse:
    """Create a comment on a post."""
    return CommentService.create_comment(post_id, comment_data, current_user.id, db)

@router.get("/posts/{post_id}/comments", response_model=List[CommentResponse])
async def get_comments(post_id: int, db: Session = Depends(get_db)) -> List[CommentResponse]:
    """Retrieve comments for a post."""
    return CommentService.get_comments(post_id, db)

@router.put("/comments/{comment_id}", response_model=CommentResponse)
async def update_comment(
    comment_id: int,
    comment_data: CommentCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> CommentResponse:
    """Update a comment."""
    comment = CommentService.update_comment(comment_id, comment_data, current_user.id, db)
    if not comment:
        raise HTTPException(status_code=404, detail="Comment not found")
    return comment

@router.delete("/comments/{comment_id}")
async def delete_comment(
    comment_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Delete a comment."""
    if not CommentService.delete_comment(comment_id, current_user.id, db):
        raise HTTPException(status_code=404, detail="Comment not found")
    return {"message": "Comment deleted"}

@router.post("/posts/{post_id}/like")
async def like_post(
    post_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> dict:
    """Like a post."""
    PostService.like_post(post_id, db)
    return {"message": "Post liked"}

# content/schemas.py
# src/content/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class PostCreate(BaseModel):
    """Schema for creating a post."""
    media_url: str
    media_type: str  # image, video, gif
    description: Optional[str] = None
    content_type: str = "basic"  # basic, archive

class PostResponse(BaseModel):
    """Schema for post response."""
    id: int
    user_id: int
    media_url: str
    media_type: str
    description: Optional[str]
    likes: int
    created_at: datetime
    is_visible: bool
    content_type: str

    class Config:
        from_attributes = True

class CommentCreate(BaseModel):
    """Schema for creating a comment."""
    content: str

class CommentResponse(BaseModel):
    """Schema for comment response."""
    id: int
    post_id: int
    user_id: int
    content: str
    created_at: datetime

    class Config:
        from_attributes = True

# content/services.py
# src/content/services.py
import hashlib
import hmac
import aiofiles
import logging
import mimetypes
import os
import shutil
import tempfile
import urllib.parse
import requests
from fastapi import HTTPException, UploadFile
from sqlalchemy.orm import Session
from datetime import datetime
from typing import Optional, List
from content.models import Post, Comment
from content.schemas import PostCreate, PostResponse, CommentCreate, CommentResponse
from config import settings

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PostService:
    @staticmethod
    async def create_post(
            file: UploadFile,
            media_type: str,
            content_type: str,
            description: Optional[str],
            user_id: int,
            db: Session
    ) -> PostResponse:
        """Create a new post with media uploaded to GCore."""
        if content_type not in ["basic", "archive"]:
            raise HTTPException(status_code=400, detail="Invalid content_type")
        if media_type not in ["image", "video", "gif"]:
            raise HTTPException(status_code=400, detail="Invalid media_type")

        mime_type, _ = mimetypes.guess_type(file.filename)
        if not mime_type or not (mime_type.startswith("image/") or mime_type.startswith("video/")):
            raise HTTPException(status_code=400, detail="File must be an image, video, or gif")

        file.file.seek(0, 2)
        file_size = file.file.tell()
        file.file.seek(0)
        if file_size > 4 * 1024 * 1024 * 1024:
            raise HTTPException(status_code=400, detail="File size exceeds 4GB")

        with tempfile.NamedTemporaryFile(delete=False, suffix=f"_{file.filename}") as temp_file:
            temp_file_path = temp_file.name
            shutil.copyfileobj(file.file, temp_file)

        try:
            file_key = f"media/{user_id}/{datetime.utcnow().timestamp()}_{urllib.parse.quote(file.filename)}"
            cdn_url = await PostService._upload_to_gcore(temp_file_path, file_key,
                                                         mime_type or "application/octet-stream")

            db_post = Post(
                user_id=user_id,
                media_url=cdn_url,
                media_type=media_type,
                content_type=content_type,
                description=description,
                is_visible=True
            )
            db.add(db_post)
            db.commit()
            db.refresh(db_post)
            return PostResponse.from_orm(db_post)
        finally:
            if os.path.exists(temp_file_path):
                os.remove(temp_file_path)

    @staticmethod
    async def _upload_to_gcore(file_path: str, file_key: str, mime_type: str) -> str:
        """Upload file to GCore and return CDN URL."""
        method = 'PUT'
        service = 's3'
        region = settings.GCORE_REGION_NAME
        host = f"{settings.GCORE_BUCKET_NAME}.s-ed1.cloud.gcore.lu"
        canonical_uri = f"/{file_key}"
        querystring = ''
        amz_date = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
        date_stamp = datetime.utcnow().strftime('%Y%m%d')
        payload_hash = PostService._calculate_payload_hash(file_path)
        headers = PostService._create_auth_headers(
            method, service, region, host, canonical_uri, querystring, payload_hash,
            settings.GCORE_ACCESS_KEY, settings.GCORE_SECRET_KEY, mime_type, amz_date, date_stamp,
            os.path.getsize(file_path)
        )
        url = f"https://{host}{canonical_uri}"
        with open(file_path, 'rb') as f:
            response = requests.put(url, data=f, headers=headers)
        if response.status_code != 200:
            logger.error(f"GCore upload failed: {response.status_code} - {response.text}")
            raise HTTPException(status_code=500,
                                detail=f"GCore upload failed: {response.status_code} - {response.text}")
        return f"{settings.GCORE_ENDPOINT_URL}/{settings.GCORE_BUCKET_NAME}/{file_key}"

    @staticmethod
    def _calculate_payload_hash(file_path: str) -> str:
        """Calculate SHA256 hash of file content."""
        sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            while chunk := f.read(8192):
                sha256.update(chunk)
        return sha256.hexdigest()

    @staticmethod
    def _create_auth_headers(
            method: str, service: str, region: str, host: str, canonical_uri: str, querystring: str,
            payload_hash: str, access_key: str, secret_key: str, content_type: str, amz_date: str, date_stamp: str,
            file_size: int
    ) -> dict:
        """Create AWS Signature V4 headers for GCore upload."""
        def sign(key, msg):
            return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()

        def get_signature_key(key, date_stamp, region_name, service_name):
            k_date = sign(('AWS4' + key).encode('utf-8'), date_stamp)
            k_region = sign(k_date, region_name)
            k_service = sign(k_region, service_name)
            k_signing = sign(k_service, 'aws4_request')
            return k_signing

        canonical_headers = f"host:{host}\nx-amz-content-sha256:{payload_hash}\nx-amz-date:{amz_date}\n"
        signed_headers = 'host;x-amz-content-sha256;x-amz-date'
        canonical_request = f'{method}\n{canonical_uri}\n{querystring}\n{canonical_headers}\n{signed_headers}\n{payload_hash}'
        algorithm = 'AWS4-HMAC-SHA256'
        credential_scope = f'{date_stamp}/{region}/{service}/aws4_request'
        string_to_sign = f'{algorithm}\n{amz_date}\n{credential_scope}\n{hashlib.sha256(canonical_request.encode("utf-8")).hexdigest()}'
        signing_key = get_signature_key(secret_key, date_stamp, region, service)
        signature = hmac.new(signing_key, string_to_sign.encode('utf-8'), hashlib.sha256).hexdigest()
        authorization_header = f'{algorithm} Credential={access_key}/{credential_scope}, SignedHeaders={signed_headers}, Signature={signature}'
        headers = {
            'Authorization': authorization_header,
            'x-amz-content-sha256': payload_hash,
            'x-amz-date': amz_date,
            'Content-Type': content_type,
            'Content-Length': str(file_size)
        }
        return headers

    @staticmethod
    def get_post(post_id: int, db: Session) -> Optional[PostResponse]:
        """Retrieve a post by ID."""
        post = db.query(Post).filter(Post.id == post_id).first()
        return PostResponse.from_orm(post) if post else None

    @staticmethod
    def update_post(post_id: int, post_data: PostCreate, db: Session) -> Optional[PostResponse]:
        """Update a post."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            return None
        if post_data.content_type not in ["basic", "archive"]:
            raise HTTPException(status_code=400, detail="Invalid content_type")
        if post_data.media_type not in ["image", "video", "gif"]:
            raise HTTPException(status_code=400, detail="Invalid media_type")
        db_post.media_url = post_data.media_url
        db_post.media_type = post_data.media_type
        db_post.description = post_data.description
        db_post.content_type = post_data.content_type
        db.commit()
        db.refresh(db_post)
        return PostResponse.from_orm(db_post)

    @staticmethod
    def delete_post(post_id: int, db: Session) -> bool:
        """Delete a post and its GCore media."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            return False
        file_key = db_post.media_url.replace(f"{settings.GCORE_ENDPOINT_URL}/{settings.GCORE_BUCKET_NAME}/", "")
        method = 'DELETE'
        service = 's3'
        region = settings.GCORE_REGION_NAME
        host = f"{settings.GCORE_BUCKET_NAME}.s-ed1.cloud.gcore.lu"
        canonical_uri = f"/{file_key}"
        querystring = ''
        amz_date = datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
        date_stamp = datetime.utcnow().strftime('%Y%m%d')
        payload_hash = hashlib.sha256(b'').hexdigest()
        headers = PostService._create_auth_headers(
            method, service, region, host, canonical_uri, querystring, payload_hash,
            settings.GCORE_ACCESS_KEY, settings.GCORE_SECRET_KEY, None, amz_date, date_stamp, 0
        )
        url = f"https://{host}{canonical_uri}"
        response = requests.delete(url, headers=headers)
        if response.status_code != 204:
            logger.error(f"GCore delete failed: {response.status_code} - {response.text}")
            raise HTTPException(status_code=500,
                                detail=f"GCore delete failed: {response.status_code} - {response.text}")
        db.delete(db_post)
        db.commit()
        return True

    @staticmethod
    def toggle_visibility(post_id: int, db: Session) -> Optional[PostResponse]:
        """Toggle post visibility."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            return None
        db_post.is_visible = not db_post.is_visible
        db.commit()
        db.refresh(db_post)
        return PostResponse.from_orm(db_post)

    @staticmethod
    def get_posts(
            user_id: Optional[int],
            content_type: Optional[str],
            media_type: Optional[str],
            db: Session
    ) -> List[PostResponse]:
        """Retrieve posts with optional filters."""
        query = db.query(Post)
        if user_id:
            query = query.filter(Post.user_id == user_id)
        if content_type:
            query = query.filter(Post.content_type == content_type)
        if media_type:
            query = query.filter(Post.media_type == media_type)
        return [PostResponse.from_orm(post) for post in query.all()]

    @staticmethod
    def like_post(post_id: int, db: Session) -> None:
        """Increment post likes."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            raise HTTPException(status_code=404, detail="Post not found")
        db_post.likes = (db_post.likes or 0) + 1
        db.commit()

class CommentService:
    @staticmethod
    def create_comment(post_id: int, comment_data: CommentCreate, user_id: int, db: Session) -> CommentResponse:
        """Create a comment on a post."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            raise HTTPException(status_code=404, detail="Post not found")
        db_comment = Comment(
            post_id=post_id,
            user_id=user_id,
            content=comment_data.content
        )
        db.add(db_comment)
        db.commit()
        db.refresh(db_comment)
        return CommentResponse.from_orm(db_comment)

    @staticmethod
    def get_comments(post_id: int, db: Session) -> List[CommentResponse]:
        """Retrieve comments for a post."""
        db_post = db.query(Post).filter(Post.id == post_id).first()
        if not db_post:
            raise HTTPException(status_code=404, detail="Post not found")
        return [CommentResponse.from_orm(comment) for comment in db_post.comments]

    @staticmethod
    def update_comment(comment_id: int, comment_data: CommentCreate, user_id: int, db: Session) -> Optional[CommentResponse]:
        """Update a comment."""
        db_comment = db.query(Comment).filter(Comment.id == comment_id, Comment.user_id == user_id).first()
        if not db_comment:
            return None
        db_comment.content = comment_data.content
        db.commit()
        db.refresh(db_comment)
        return CommentResponse.from_orm(db_comment)

    @staticmethod
    def delete_comment(comment_id: int, user_id: int, db: Session) -> bool:
        """Delete a comment."""
        db_comment = db.query(Comment).filter(Comment.id == comment_id, Comment.user_id == user_id).first()
        if not db_comment:
            return False
        db.delete(db_comment)
        db.commit()
        return True

# database.py
# src/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from config import settings

# Create the database engine
engine = create_engine(settings.DATABASE_URL)

# Create a session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()

def get_db():
    """Provide a database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# main.py
# src/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from auth.routes import router as auth_router
from content.routes import router as content_router
from subscription.routes import router as subscription_router
from payment.routes import router as payment_router
from admin.routes import router as admin_router
from scheduler.tasks import start_scheduler, check_pending_payments

app = FastAPI(
    title="Content Site Backend",
    description="API for content site with media streaming",
    version="0.1.0",
)

# Configure CORS
origins = ["http://localhost:5173", "http://localhost", "http://127.0.0.1:5173"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth_router)
app.include_router(content_router)
app.include_router(subscription_router)
app.include_router(payment_router)
app.include_router(admin_router)

@app.on_event("startup")
async def startup_event():
    """Run initial tasks on startup."""
    check_pending_payments()
    start_scheduler()

@app.get("/")
async def root():
    """Root endpoint."""
    return {"message": "Welcome to Content Site Backend!"}

# migrations/env.py
# migrations/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
from database import Base
from auth.models import User, AdminActionLog
from content.models import Post, Comment
from subscription.models import Subscription
from payment.models import Payment, Discount

config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

config.set_main_option("sqlalchemy.url", "postgresql+psycopg2://postgres:1234@localhost:5433/mydb2")
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
        )
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

# migrations/versions/43543ba33103_initial_migration.py
"""Initial migration

Revision ID: 43543ba33103
Revises: 
Create Date: 2025-07-30 01:43:53.307686

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '43543ba33103'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password_hash', sa.String(), nullable=False),
    sa.Column('subscription_level', sa.String(), nullable=True),
    sa.Column('date_of_birth', sa.Date(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('role', sa.String(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)
    op.create_table('admin_action_logs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('admin_id', sa.Integer(), nullable=False),
    sa.Column('action', sa.String(), nullable=False),
    sa.Column('timestamp', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['admin_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_admin_action_logs_id'), 'admin_action_logs', ['id'], unique=False)
    op.create_table('discounts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('discount_type', sa.String(), nullable=False),
    sa.Column('discount_percentage', sa.Integer(), nullable=False),
    sa.Column('code', sa.String(), nullable=True),
    sa.Column('valid_until', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_discounts_id'), 'discounts', ['id'], unique=False)
    op.create_table('posts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('media_url', sa.String(), nullable=False),
    sa.Column('media_type', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('likes', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('is_visible', sa.Boolean(), nullable=False),
    sa.Column('content_type', sa.String(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_posts_id'), 'posts', ['id'], unique=False)
    op.create_table('subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('level', sa.String(), nullable=False),
    sa.Column('expiry_date', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_subscriptions_id'), 'subscriptions', ['id'], unique=False)
    op.create_table('comments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('post_id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('content', sa.Text(), nullable=False),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['post_id'], ['posts.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_comments_id'), 'comments', ['id'], unique=False)
    op.create_table('payments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('subscription_id', sa.Integer(), nullable=False),
    sa.Column('discount_id', sa.Integer(), nullable=True),
    sa.Column('payment_method', sa.String(), nullable=False),
    sa.Column('payment_id', sa.String(), nullable=True),
    sa.Column('transaction_id', sa.String(), nullable=True),
    sa.Column('amount', sa.Integer(), nullable=False),
    sa.Column('currency', sa.String(), nullable=False),
    sa.Column('payout_currency', sa.String(), nullable=True),
    sa.Column('discount_applied', sa.Integer(), nullable=True),
    sa.Column('status', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.Column('expiration_time', sa.DateTime(), nullable=False),
    sa.ForeignKeyConstraint(['discount_id'], ['discounts.id'], ),
    sa.ForeignKeyConstraint(['subscription_id'], ['subscriptions.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_payments_id'), 'payments', ['id'], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_payments_id'), table_name='payments')
    op.drop_table('payments')
    op.drop_index(op.f('ix_comments_id'), table_name='comments')
    op.drop_table('comments')
    op.drop_index(op.f('ix_subscriptions_id'), table_name='subscriptions')
    op.drop_table('subscriptions')
    op.drop_index(op.f('ix_posts_id'), table_name='posts')
    op.drop_table('posts')
    op.drop_index(op.f('ix_discounts_id'), table_name='discounts')
    op.drop_table('discounts')
    op.drop_index(op.f('ix_admin_action_logs_id'), table_name='admin_action_logs')
    op.drop_table('admin_action_logs')
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_index(op.f('ix_users_id'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
    # ### end Alembic commands ###


# payment/models.py
# src/payment/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class Payment(Base):
    """Represents a payment for a subscription."""
    __tablename__ = "payments"

    id: int = Column(Integer, primary_key=True, index=True)
    subscription_id: int = Column(Integer, ForeignKey("subscriptions.id"), nullable=False)
    discount_id: int = Column(Integer, ForeignKey("discounts.id"), nullable=True)
    payment_method: str = Column(String, nullable=False)
    payment_id: str = Column(String, nullable=True)
    transaction_id: str = Column(String, nullable=True)
    amount: int = Column(Integer, nullable=False)
    currency: str = Column(String, nullable=False)
    payout_currency: str = Column(String, default="USDT")
    discount_applied: int = Column(Integer, default=0)
    status: str = Column(String, default="pending")
    created_at: datetime = Column(DateTime, default=datetime.utcnow)
    expiration_time: datetime = Column(DateTime, nullable=False)

    subscription = relationship("Subscription", back_populates="payments")
    discount = relationship("Discount", back_populates="payments")

class Discount(Base):
    """Represents a discount for payments."""
    __tablename__ = "discounts"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=True)
    discount_type: str = Column(String, nullable=False)
    discount_percentage: int = Column(Integer, nullable=False)
    code: str = Column(String, nullable=True)
    valid_until: datetime = Column(DateTime, nullable=True)
    is_active: bool = Column(Boolean, default=True)
    created_at: datetime = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="discounts")
    payments = relationship("Payment", back_populates="discount")

# payment/routes.py
# src/payment/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from payment.services import PaymentService
from payment.schemas import PaymentResponse, DiscountCreate, DiscountResponse
from payment.models import Payment
from subscription.models import Subscription
from auth.routes import get_current_user
from auth.models import User
from database import get_db
from datetime import datetime
from config import settings

router = APIRouter(prefix="/payments", tags=["payments"])

def check_admin_role(current_user: User = Depends(get_current_user)) -> User:
    """Ensure the user has admin role."""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    return current_user

@router.get("/check-payment/{payment_id}")
def check_payment(
    payment_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Check payment status."""
    expired_payments = db.query(Payment).filter(
        Payment.status == "pending",
        Payment.expiration_time < datetime.utcnow()
    ).all()
    for payment in expired_payments:
        payment.status = "expired"
    db.commit()

    payment = db.query(Payment).filter(Payment.payment_id == payment_id).first()
    if not payment:
        raise HTTPException(status_code=404, detail="Payment not found")

    if payment.status == "pending" and datetime.utcnow() > payment.expiration_time:
        payment.status = "expired"
        db.commit()
        raise HTTPException(status_code=400, detail="Payment expired")

    payment_service = PaymentService()
    if payment_service.check_payment(payment, db):
        subscription = payment.subscription
        subscription.expiry_date = datetime.utcnow() + timedelta(days=settings.SUBSCRIPTION_DURATION_DAYS)
        current_user.subscription_level = subscription.level
        db.commit()
        return {"status": "confirmed"}
    return {"status": payment.status}

@router.get("/", response_model=List[PaymentResponse])
def get_user_payments(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Retrieve user payments."""
    return PaymentService.get_user_payments(current_user.id, db)

@router.post("/discounts", response_model=DiscountResponse, dependencies=[Depends(check_admin_role)])
def create_discount(
    discount: DiscountCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Create a new discount."""
    return PaymentService.create_discount(discount, db)

@router.put("/discounts/{discount_id}", response_model=DiscountResponse, dependencies=[Depends(check_admin_role)])
def update_discount(
    discount_id: int,
    discount_data: DiscountCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Update a discount."""
    discount = PaymentService.update_discount(discount_id, discount_data, db)
    if not discount:
        raise HTTPException(status_code=404, detail="Discount not found")
    return discount

@router.delete("/discounts/{discount_id}", dependencies=[Depends(check_admin_role)])
def delete_discount(
    discount_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Delete a discount."""
    if not PaymentService.delete_discount(discount_id, db):
        raise HTTPException(status_code=404, detail="Discount not found")
    return {"message": "Discount deleted"}

@router.get("/discounts", response_model=List[DiscountResponse], dependencies=[Depends(check_admin_role)])
def get_discounts(
    db: Session = Depends(get_db),
    current_user: User = Depends(check_admin_role)
):
    """Retrieve all discounts."""
    return PaymentService.get_discounts(db)

# payment/schemas.py
# src/payment/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class PaymentResponse(BaseModel):
    """Schema for payment response."""
    id: int
    subscription_id: int
    discount_id: Optional[int]
    payment_method: str
    payment_id: Optional[str]
    transaction_id: Optional[str]
    amount: int
    currency: str
    payout_currency: Optional[str]
    discount_applied: int
    status: str
    created_at: datetime

    class Config:
        from_attributes = True

class PaymentCreateResponse(BaseModel):
    """Schema for payment creation response."""
    payment_id: str
    payment_url: str
    amount: float
    final_amount: float
    discount_info: str

class DiscountCreate(BaseModel):
    """Schema for creating a discount."""
    discount_type: str
    discount_percentage: int
    code: Optional[str] = None
    valid_until: Optional[datetime] = None
    is_active: bool = True

class DiscountResponse(BaseModel):
    """Schema for discount response."""
    id: int
    user_id: Optional[int]
    discount_type: str
    discount_percentage: int
    code: Optional[str]
    valid_until: Optional[datetime]
    is_active: bool
    created_at: datetime
    usage_count: int

    class Config:
        from_attributes = True

# payment/services.py
# src/payment/services.py
from web3 import Web3
from fastapi import HTTPException
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import Optional
from payment.models import Payment, Discount
from payment.schemas import PaymentResponse, DiscountCreate, DiscountResponse
from subscription.models import Subscription
from config import settings
import requests
import json

class PaymentService:
    def __init__(self):
        self.tron_wallet_address = settings.TRON_WALLET_ADDRESS
        self.bsc = Web3(Web3.HTTPProvider(settings.BSC_FULL_NODE))
        self.bsc_wallet_address = settings.BSC_WALLET_ADDRESS
        self.usdt_trc20_address = settings.USDT_TRC20_ADDRESS
        self.usdt_bep20_address = settings.USDT_BEP20_ADDRESS
        self.usdt_bep20_abi = [
            {
                "anonymous": False,
                "inputs": [
                    {"indexed": True, "internalType": "address", "name": "from", "type": "address"},
                    {"indexed": True, "internalType": "address", "name": "to", "type": "address"},
                    {"indexed": False, "internalType": "uint256", "name": "value", "type": "uint256"}
                ],
                "name": "Transfer",
                "type": "event"
            }
        ]
        self.usdt_bep20_contract = self.bsc.eth.contract(
            address=self.usdt_bep20_address,
            abi=self.usdt_bep20_abi
        )

    def generate_unique_amount(self, base_price: float, db: Session) -> float:
        """Generate a unique payment amount to avoid conflicts."""
        amounts_to_try = [
            base_price,
            base_price - 0.01,
            base_price + 0.01,
            base_price - 0.02,
            base_price + 0.02,
        ]
        for amount in amounts_to_try:
            existing_payment = db.query(Payment).filter(
                Payment.amount == int(amount * 100),
                Payment.status == "pending",
                Payment.expiration_time >= datetime.utcnow()
            ).first()
            if not existing_payment:
                return amount
        raise HTTPException(status_code=400, detail="No available unique amount")

    def create_payment(self, amount: float, currency: str, db: Session) -> dict:
        """Create a payment request."""
        if currency == "usdttrc20":
            address = self.tron_wallet_address
        elif currency == "usdtbep20":
            address = self.bsc_wallet_address
        elif currency == "bnb":
            address = self.bsc_wallet_address
        else:
            raise HTTPException(status_code=400, detail="Unsupported currency")
        return {"payment_url": address, "amount": amount}

    def check_payment(self, payment: Payment, db: Session) -> bool:
        """Check payment status in blockchain."""
        amount_in_usd = payment.amount / 100.0
        if payment.currency == "usdttrc20":
            url = f"https://nile.trongrid.io/v1/accounts/{self.tron_wallet_address}/transactions/trc20"
            params = {"contract_address": self.usdt_trc20_address}
            response = requests.get(url, params=params).json()
            for tx in response.get("data", []):
                if (tx["to"] == self.tron_wallet_address and
                    float(tx["value"]) / 10**6 == amount_in_usd):
                    payment.transaction_id = tx["transaction_id"]
                    payment.status = "confirmed"
                    db.commit()
                    return True
        elif payment.currency in ["usdtbep20", "bnb"]:
            latest_block = self.bsc.eth.block_number
            for block in range(latest_block - 100, latest_block + 1):
                if payment.currency == "usdtbep20":
                    try:
                        transfer_events = self.usdt_bep20_contract.events.Transfer.get_logs(
                            fromBlock=block,
                            toBlock=block,
                            argument_filters={"to": self.bsc_wallet_address}
                        )
                        for event in transfer_events:
                            amount_transferred = event["args"]["value"] / 10**18
                            if amount_transferred == amount_in_usd:
                                payment.transaction_id = event["transactionHash"].hex()
                                payment.status = "confirmed"
                                db.commit()
                                return True
                    except Exception:
                        continue
                elif payment.currency == "bnb":
                    block_data = self.bsc.eth.get_block(block, full_transactions=True)
                    for tx in block_data.transactions:
                        if (tx.get("to") == self.bsc_wallet_address and
                            float(tx.get("value", 0)) / 10**18 == amount_in_usd):
                            payment.transaction_id = tx["hash"].hex()
                            payment.status = "confirmed"
                            db.commit()
                            return True
        return False

    @staticmethod
    def get_user_payments(user_id: int, db: Session) -> list[PaymentResponse]:
        """Retrieve all payments for a user."""
        payments = db.query(Payment).join(Subscription).filter(Subscription.user_id == user_id).all()
        return [PaymentResponse.from_orm(payment) for payment in payments]

    @staticmethod
    def create_discount(discount_data: DiscountCreate, db: Session) -> DiscountResponse:
        """Create a new discount."""
        db_discount = Discount(**discount_data.dict())
        db.add(db_discount)
        db.commit()
        db.refresh(db_discount)
        usage_count = db.query(Payment).filter(Payment.discount_id == db_discount.id).count()
        return DiscountResponse(**db_discount.__dict__, usage_count=usage_count)

    @staticmethod
    def update_discount(discount_id: int, discount_data: DiscountCreate, db: Session) -> Optional[DiscountResponse]:
        """Update a discount."""
        db_discount = db.query(Discount).filter(Discount.id == discount_id).first()
        if not db_discount:
            return None
        for key, value in discount_data.dict().items():
            setattr(db_discount, key, value)
        db.commit()
        db.refresh(db_discount)
        usage_count = db.query(Payment).filter(Payment.discount_id == db_discount.id).count()
        return DiscountResponse(**db_discount.__dict__, usage_count=usage_count)

    @staticmethod
    def delete_discount(discount_id: int, db: Session) -> bool:
        """Delete a discount."""
        db_discount = db.query(Discount).filter(Discount.id == discount_id).first()
        if not db_discount:
            return False
        db.delete(db_discount)
        db.commit()
        return True

    @staticmethod
    def get_discounts(db: Session) -> list[DiscountResponse]:
        """Retrieve all discounts."""
        discounts = db.query(Discount).all()
        return [
            DiscountResponse(**discount.__dict__, usage_count=db.query(Payment).filter(Payment.discount_id == discount.id).count())
            for discount in discounts
        ]

# py_to_txt.py
import os
import fnmatch

# ===  ===
OUTPUT_FILE = "project_dump.txt"  #  
ROOT_DIR = os.getcwd()  #  
IGNORED_DIRS = {".venv", "venv", "__pycache__", ".git"}  #   
IGNORED_FILES = {"*.pyc", "*.pyo", "*.log"}  #    


def is_empty_init(file_path):
    """,    __init__.py """
    return os.path.basename(file_path) == "__init__.py" and os.path.getsize(file_path) == 0


def is_ignored(file_name, dir_path):
    """,   """
    #   
    for pattern in IGNORED_FILES:
        if fnmatch.fnmatch(file_name, pattern):
            return True
    return False


def collect_python_files(root):
    """  .py ,  """
    python_files = []
    for dirpath, dirnames, filenames in os.walk(root):
        #   
        dirnames[:] = [d for d in dirnames if d not in IGNORED_DIRS]
        for filename in filenames:
            if filename.endswith(".py") and not is_ignored(filename, dirpath):
                full_path = os.path.join(dirpath, filename)
                if not is_empty_init(full_path):
                    python_files.append(full_path)
    return sorted(python_files)


def relative_path(path, root):
    """    root"""
    return os.path.relpath(path, root).replace("\\", "/")


def build_dump(root, output_file):
    files = collect_python_files(root)
    with open(output_file, "w", encoding="utf-8") as out:
        for file_path in files:
            rel_path = relative_path(file_path, root)
            out.write(f"\n# {rel_path}\n")
            with open(file_path, "r", encoding="utf-8") as f:
                out.write(f.read())
                out.write("\n")
    print(f" {len(files)}   {output_file}")


if __name__ == "__main__":
    build_dump(ROOT_DIR, OUTPUT_FILE)

# scheduler/tasks.py
# src/scheduler/tasks.py
import logging
from apscheduler.schedulers.background import BackgroundScheduler
from sqlalchemy.orm import Session
from datetime import datetime
from database import SessionLocal
from payment.models import Payment
from payment.services import PaymentService

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def check_pending_payments():
    """Check and update pending payments."""
    logger.info("Starting check_pending_payments task")
    db: Session = SessionLocal()
    try:
        pending_payments = db.query(Payment).filter(Payment.status == "pending").all()
        payment_service = PaymentService()
        for payment in pending_payments:
            logger.info(f"Checking payment: {payment.payment_id}, expiration_time: {payment.expiration_time}")
            if payment.expiration_time is None or payment.expiration_time < datetime.utcnow():
                payment.status = "expired"
                db.commit()
                logger.info(f"Payment {payment.payment_id} marked as expired")
                continue
            if payment_service.check_payment(payment, db):
                logger.info(f"Payment {payment.payment_id} confirmed")
    except Exception as e:
        logger.error(f"Error in check_pending_payments: {str(e)}")
    finally:
        db.close()
    logger.info("Finished check_pending_payments task")

def archive_old_posts():
    """Archive posts older than 1 year."""
    logger.info("Starting archive_old_posts task")
    db: Session = SessionLocal()
    try:
        db.execute(
            "UPDATE posts SET content_type = 'archive' WHERE content_type = 'basic' AND created_at < NOW() - INTERVAL '1 year'"
        )
        db.commit()
        logger.info("Successfully archived old posts")
    except Exception as e:
        logger.error(f"Error in archive_old_posts: {str(e)}")
    finally:
        db.close()
    logger.info("Finished archive_old_posts task")

def start_scheduler():
    """Start the background scheduler."""
    scheduler = BackgroundScheduler()
    scheduler.add_job(check_pending_payments, 'interval', minutes=5)
    scheduler.add_job(archive_old_posts, 'interval', days=1)
    scheduler.start()

# subscription/models.py
# src/subscription/models.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class Subscription(Base):
    """Represents a user subscription."""
    __tablename__ = "subscriptions"

    id: int = Column(Integer, primary_key=True, index=True)
    user_id: int = Column(Integer, ForeignKey("users.id"), nullable=False)
    level: str = Column(String, nullable=False)
    expiry_date: datetime = Column(DateTime, nullable=False)

    user = relationship("User", back_populates="subscriptions")
    payments = relationship("Payment", back_populates="subscription")

# subscription/routes.py
# src/subscription/routes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from subscription.services import SubscriptionService
from subscription.schemas import SubscriptionCreate, SubscriptionResponse
from payment.schemas import PaymentCreateResponse
from auth.routes import get_current_user
from database import get_db
from auth.models import User

router = APIRouter(prefix="/subscriptions", tags=["subscriptions"])

@router.post("/", response_model=PaymentCreateResponse)
def create_subscription(
    subscription_data: SubscriptionCreate,
    currency: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Create or extend a subscription."""
    return SubscriptionService.create_subscription(subscription_data, currency, current_user, db)

@router.get("/", response_model=List[SubscriptionResponse])
def get_user_subscriptions(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Retrieve user subscriptions."""
    return SubscriptionService.get_user_subscriptions(current_user.id, db)

# subscription/schemas.py
# src/subscription/schemas.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SubscriptionCreate(BaseModel):
    """Schema for creating a subscription."""
    level: str
    promo_code: Optional[str] = None

class SubscriptionResponse(BaseModel):
    """Schema for subscription response."""
    id: int
    user_id: int
    level: str
    expiry_date: datetime

    class Config:
        from_attributes = True

# subscription/services.py
# src/subscription/services.py
from fastapi import HTTPException
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from typing import Optional, Tuple
from subscription.models import Subscription
from subscription.schemas import SubscriptionCreate, SubscriptionResponse
from payment.models import Payment, Discount
from payment.services import PaymentService
from auth.models import User
from config import settings

class SubscriptionService:
    @staticmethod
    def get_discount(promo_code: Optional[str], db: Session) -> Tuple[Optional[int], float, str]:
        """Retrieve discount details if valid promo code is provided."""
        if not promo_code:
            return None, 0.0, ""
        discount = db.query(Discount).filter(
            Discount.code == promo_code,
            Discount.is_active == True,
            Discount.valid_until >= datetime.utcnow()
        ).first()
        if discount:
            return discount.id, discount.discount_percentage / 100.0, f"Applied promo code {promo_code}, discount {discount.discount_percentage}%"
        return None, 0.0, ""

    @staticmethod
    def create_subscription(
        subscription_data: SubscriptionCreate,
        currency: str,
        user: User,
        db: Session
    ) -> dict:
        """Create or extend a subscription with payment."""
        if subscription_data.level not in settings.SUBSCRIPTION_PRICES:
            raise HTTPException(status_code=400, detail="Invalid subscription level")

        today = datetime.utcnow().date()
        dob = user.date_of_birth
        age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
        if age < 18:
            raise HTTPException(status_code=403, detail="You must be 18 or older to subscribe")

        active_subscription = db.query(Subscription).filter(
            Subscription.user_id == user.id,
            Subscription.expiry_date >= datetime.utcnow()
        ).first()

        base_price = settings.SUBSCRIPTION_PRICES[subscription_data.level]
        payment_service = PaymentService()
        unique_amount = payment_service.generate_unique_amount(base_price, db)

        if active_subscription:
            if active_subscription.level == subscription_data.level:
                unique_amount = base_price
            elif settings.SUBSCRIPTION_PRICES[active_subscription.level] > settings.SUBSCRIPTION_PRICES[subscription_data.level]:
                raise HTTPException(
                    status_code=400,
                    detail=f"You have an active {active_subscription.level} subscription until {active_subscription.expiry_date}. Downgrading is not allowed."
                )
            else:
                unique_amount = settings.SUBSCRIPTION_PRICES[subscription_data.level] - settings.SUBSCRIPTION_PRICES[active_subscription.level]

        final_price = int(unique_amount * 100)
        discount_id, discount, discount_info = SubscriptionService.get_discount(subscription_data.promo_code, db)
        if discount > 0:
            final_amount = unique_amount * (1 - discount)
            final_price = int(final_amount * 100)
        else:
            final_amount = unique_amount

        if active_subscription and active_subscription.level == subscription_data.level:
            active_subscription.expiry_date = active_subscription.expiry_date + timedelta(days=settings.SUBSCRIPTION_DURATION_DAYS)
            new_subscription = active_subscription
        else:
            expiry_date = datetime.utcnow() + timedelta(days=settings.SUBSCRIPTION_DURATION_DAYS)
            new_subscription = Subscription(
                user_id=user.id,
                level=subscription_data.level,
                expiry_date=expiry_date
            )
            db.add(new_subscription)
            if active_subscription:
                active_subscription.expiry_date = datetime.utcnow()

        db.commit()
        db.refresh(new_subscription)

        expiration_time = datetime.utcnow() + timedelta(minutes=30)
        new_payment = Payment(
            subscription_id=new_subscription.id,
            discount_id=discount_id,
            payment_method="crypto",
            payment_id=f"pay_{new_subscription.id}_{datetime.utcnow().timestamp()}",
            transaction_id=None,
            amount=final_price,
            currency=currency,
            discount_applied=int((unique_amount - final_amount) * 100) if discount_id else 0,
            status="pending",
            expiration_time=expiration_time
        )
        db.add(new_payment)
        db.commit()
        db.refresh(new_payment)

        payment_response = payment_service.create_payment(final_amount, currency, db)
        return {
            "payment_id": new_payment.payment_id,
            "payment_url": payment_response["payment_url"],
            "amount": final_amount,
            "final_amount": final_amount,
            "discount_info": discount_info
        }

    @staticmethod
    def get_user_subscriptions(user_id: int, db: Session) -> list[SubscriptionResponse]:
        """Retrieve all subscriptions for a user."""
        subscriptions = db.query(Subscription).filter(Subscription.user_id == user_id).all()
        return [SubscriptionResponse.from_orm(sub) for sub in subscriptions]
